<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Week 4 - Practical – SPRT2002 Prac Book</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Practical4.html" rel="next">
<link href="./Practical2.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-b343bb23504f009ddf7b24643a6af19a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="include/webex.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Practical3.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Week 4 - Practical</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">SPRT2002 Prac Book</a> 
        <div class="sidebar-tools-main">
    <a href="./index.html" title="Home" class="quarto-navigation-tool px-1" aria-label="Home"><i class="bi bi-house-fill"></i></a>
    <div class="dropdown">
      <a href="" title="Download" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label="Download"><i class="bi bi-download"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="./SPRT2002-Prac-Book.pdf">
              <i class="bi bi-file-pdf pe-1"></i>
            Download PDF
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="./SPRT2002-Prac-Book.epub">
              <i class="bi bi-journal pe-1"></i>
            Download ePub
            </a>
          </li>
      </ul>
    </div>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Practical1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Week 2 - Practical</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Practical2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Week 3 - Practical</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Practical3.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Week 4 - Practical</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Practical4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Week 5 - Practical</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Practical5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Week 6 - Practical</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#learning-outcome" id="toc-learning-outcome" class="nav-link active" data-scroll-target="#learning-outcome"><span class="header-section-number">3.1</span> Learning Outcome:</a></li>
  <li><a href="#practical-goals" id="toc-practical-goals" class="nav-link" data-scroll-target="#practical-goals"><span class="header-section-number">3.2</span> Practical Goals:</a></li>
  <li><a href="#example-case-study" id="toc-example-case-study" class="nav-link" data-scroll-target="#example-case-study"><span class="header-section-number">3.3</span> Example case study</a>
  <ul class="collapse">
  <li><a href="#correlation-and-regression" id="toc-correlation-and-regression" class="nav-link" data-scroll-target="#correlation-and-regression"><span class="header-section-number">3.3.1</span> Correlation and regression</a></li>
  </ul></li>
  <li><a href="#practical-procedures-part-1" id="toc-practical-procedures-part-1" class="nav-link" data-scroll-target="#practical-procedures-part-1"><span class="header-section-number">3.4</span> Practical Procedures (PART 1)</a></li>
  <li><a href="#reflection" id="toc-reflection" class="nav-link" data-scroll-target="#reflection"><span class="header-section-number">3.5</span> Reflection</a></li>
  <li><a href="#section-2---bland-altman-plot" id="toc-section-2---bland-altman-plot" class="nav-link" data-scroll-target="#section-2---bland-altman-plot"><span class="header-section-number">3.6</span> Section 2 - Bland Altman plot</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Week 4 - Practical</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="learning-outcome" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="learning-outcome"><span class="header-section-number">3.1</span> Learning Outcome:</h2>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
<ol type="1">
<li><p>Understand measurement accuracy concepts and their application to exercise testing and measurement</p></li>
<li><p>Evaluate the feasibility of different tests according to environmental conditions and client characteristics</p></li>
<li><p>Demonstrate basic data processing and analytically techniques</p></li>
</ol>
<p><br></p>
</section>
<section id="practical-goals" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="practical-goals"><span class="header-section-number">3.2</span> Practical Goals:</h2>
<ol type="1">
<li><p>3rd round of data collection for practical report 2</p></li>
<li><p>Practice developing skills at running and collecting commonly used test for assessment of cardiovascular fitness and parasympathetic vs sympathetic activity.</p></li>
<li><p>Understand how measures collected would be practically applied in the field, considering important limitations to the measures.</p></li>
<li><p>Understand basic intuition around how correlation plots can be used as a measure of convergent validity between measures testing the same trait/construct.</p></li>
<li><p>Time permitting; practise making Bland-Altman plots using data collected from previous weeks.</p></li>
</ol>
<p><br></p>
</section>
<section id="example-case-study" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="example-case-study"><span class="header-section-number">3.3</span> Example case study</h2>
<p>You hired by an organisation that are use different testing modalities to infer cardiovascular fitness. Namely, they are currently using a combination of a 3 minute step up test, 4 minute fixed wattage bike test and 4 minute run test at 8.5km.hr. The company/team want to know how related these test are. More explicitly they want to know if they knew the result of one test could they use it to infer what the individual may have got on one of the other test.</p>
<p>How might you go about answering this? <br></p>
<section id="correlation-and-regression" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="correlation-and-regression"><span class="header-section-number">3.3.1</span> Correlation and regression</h3>
<p>In this situation the business/club is asking a question about how much does one test tell us about another test. Or put another way how correlated/associated is one test with another.</p>
<p>Whilst, there are may different ways to get a measure of association/correlation, the most common method is via using simple linear regression (think line of best of fit), and calculating something called a correlation coefficient.</p>
<p>We will go over these measures in a lot more detail in the Week 5 lecture. <br></p>
<div class="callout callout-style-default callout-tip callout-titled" title="Interactive regression">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Interactive regression
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<!-- Linear Regression Visualization with namespaced classes and IDs to avoid conflicts -->
<div class="lr-container">
    <style>
        .lr-container {
            max-width: 100%;
            margin: 0 auto;
            font-family: 'Roboto', sans-serif;
        }
        
        .lr-container h1 {
            font-family: 'Poppins', sans-serif;
            text-align: center;
            color: #3a0ca3;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
            font-size: 1.5em;
            display: none; /* Hide any h1 tags */
        }
        
        .lr-chart-container {
            background-color: white;
            border-radius: 12px;
            padding: 10px 15px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.05), 0 2px 8px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .lr-controls {
            margin-bottom: 15px;
            background-color: white;
            border-radius: 12px;
            padding: 12px 15px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.05), 0 2px 8px rgba(0, 0, 0, 0.05);
            width: 100%;
            box-sizing: border-box;
        }
        
        .lr-slider-container {
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .lr-button-container {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        
        .lr-slider-label {
            display: inline-block;
            width: 180px;
            font-weight: 500;
            color: #212529;
        }
        
        .lr-slider {
            flex: 1;
            max-width: 350px;
            height: 6px;
            background: linear-gradient(to right, #d8e2ef, #4361ee);
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
            margin: 0 15px;
        }
        
        .lr-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4361ee;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }
        
        .lr-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        
        .lr-value-display {
            display: inline-block;
            width: 60px;
            text-align: center;
            font-weight: 500;
            color: #4361ee;
            background: #eef1ff;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .lr-optimal-value {
            display: inline-block;
            margin-left: 5px;
            color: #2dc653;
            font-weight: 500;
        }
        
        .lr-button {
            padding: 10px 16px;
            background-color: #4361ee;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .lr-button:hover {
            background-color: #3a0ca3;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .lr-button-optimal {
            background-color: #2dc653;
        }
        
        .lr-button-optimal:hover {
            background-color: #25a244;
        }
        
        .lr-button-residuals, .lr-button-squares {
            background-color: #f9c74f;
            color: #212529;
        }
        
        .lr-button-residuals:hover, .lr-button-squares:hover {
            background-color: #f0b429;
        }
        
        .lr-button-download {
            background-color: #6c757d;
        }
        
        .lr-button-download:hover {
            background-color: #5a6268;
        }
        
        .lr-tooltip {
            position: absolute;
            background-color: rgba(33, 37, 41, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 400;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .lr-equations-container {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            margin: 5px 0;
            padding: 6px 10px;
            background-color: #f8f9ff;
            border-radius: 6px;
            gap: 10px;
        }
        
        .lr-equation {
            font-size: 14px;
            font-weight: 500;
            padding: 4px 8px;
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.7);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        
        .lr-manual-equation {
            color: #ef476f;
        }
        
        .lr-optimal-equation {
            color: #2dc653;
            font-size: 16px;
        }
        
        .lr-mean-line {
            stroke-dasharray: 5,5;
            stroke-width: 1.5;
        }
        
        .lr-stats-container {
            background-color: white;
            border-radius: 12px;
            padding: 10px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.05), 0 2px 8px rgba(0, 0, 0, 0.05);
            margin-top: 10px;
            margin-bottom: 10px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .lr-stats {
            font-size: 14px;
            line-height: 1.4;
            color: #212529;
        }
        
        .lr-stats p {
            margin: 3px 0;
        }
        
        .lr-stats-highlight {
            font-weight: 600;
            color: #2dc653;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .lr-slider-container {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .lr-slider-label {
                margin-bottom: 8px;
                width: 100%;
            }
            
            .lr-slider {
                width: 100%;
                margin: 0 0 15px 0;
            }
            
            .lr-button-container {
                justify-content: center;
            }
            
            .lr-button {
                margin-bottom: 10px;
            }
        }
    </style>

    <div class="lr-controls">
        <div class="lr-slider-container">
            <span class="lr-slider-label">Correlation Strength:</span>
            <input type="range" id="lr-correlation" class="lr-slider" min="-1" max="1" step="0.05" value="0.7">
            <span class="lr-value-display" id="lr-correlation-value">0.7</span>
        </div>
        
        <div class="lr-slider-container">
            <span class="lr-slider-label">Intercept (β₀):<span class="lr-optimal-value" id="lr-optimal-intercept-value"></span></span>
            <input type="range" id="lr-intercept" class="lr-slider" min="0" max="100" step="0.1" value="5">
            <span class="lr-value-display" id="lr-intercept-value">5</span>
        </div>
        
        <div class="lr-slider-container">
            <span class="lr-slider-label">Slope (β₁):<span class="lr-optimal-value" id="lr-optimal-slope-value"></span></span>
            <input type="range" id="lr-slope" class="lr-slider" min="-3" max="3" step="0.05" value="1">
            <span class="lr-value-display" id="lr-slope-value">1</span>
        </div>
        
        <div class="lr-button-container">
            <button id="lr-generate-data" class="lr-button">Generate New Data</button>
            <button id="lr-toggle-line" class="lr-button">Hide Regression Line</button>
            <button id="lr-show-residuals" class="lr-button lr-button-residuals">Show Residuals</button>
            <button id="lr-show-squares" class="lr-button lr-button-squares">Show Squared Errors</button>
            <button id="lr-show-optimal" class="lr-button lr-button-optimal">Hide Optimal Line</button>
            <button id="lr-show-means" class="lr-button">Show Mean Lines</button>
            <button id="lr-download-csv" class="lr-button lr-button-download">Download CSV</button>
        </div>
    </div>
    
    <div class="lr-chart-container">
        <div class="lr-equations-container">
            <div class="lr-equation lr-manual-equation" id="lr-equation-display">y = 1x + 5</div>
            <div class="lr-equation lr-optimal-equation" id="lr-optimal-equation-display"></div>
        </div>
        <div id="lr-scatter-plot"></div>
    </div>
    
    <!-- New container for optimal regression statistics -->
    <div class="lr-stats-container">
        <div class="lr-stats" id="lr-optimal-stats"></div>
    </div>

    <script>
        // IIFE to avoid global scope pollution
        (function() {
            // Configuration
            const lrConfig = {
                mainChart: {
                    width: 400,
                    height: 320, // Reduced height from 450 to 320
                    margin: { top: 25, right: 30, bottom: 40, left: 60 } // Slightly reduced top/bottom margins
                },
                pointCount: 40,
                xRange: [0, 100],
                yRange: [0, 100]
            };

            // State variables
            let lrData = [];
            let lrCorrelation = 0.7;
            let lrIntercept = 5;
            let lrSlope = 1;
            let lrShowResiduals = false;
            let lrShowSquares = false;
            let lrShowLine = true;
            let lrShowOptimalLine = true; // Changed to true by default
            let lrShowMeanLines = false;
            let lrOptimalParams = { intercept: 0, slope: 0 };

            // Initialize the main chart with responsive design
            const lrSvg = d3.select("#lr-scatter-plot")
                .append("svg")
                .attr("width", "100%") // Set width to 100% for responsiveness
                .attr("height", "100%") // Set height to 100% for responsiveness
                .attr("viewBox", `0 0 ${lrConfig.mainChart.width} ${lrConfig.mainChart.height}`) // Use viewBox for scaling
                .attr("preserveAspectRatio", "xMidYMid meet"); // Maintain aspect ratio
                
            // Create tooltip
            const lrTooltip = d3.select(".lr-container").append("div")
                .attr("class", "lr-tooltip")
                .style("opacity", 0);

            // Set up scales
            const lrXScale = d3.scaleLinear()
                .domain(lrConfig.xRange)
                .range([lrConfig.mainChart.margin.left, lrConfig.mainChart.width - lrConfig.mainChart.margin.right]);
                
            const lrYScale = d3.scaleLinear()
                .domain(lrConfig.yRange)
                .range([lrConfig.mainChart.height - lrConfig.mainChart.margin.bottom, lrConfig.mainChart.margin.top]);

            // Create axes
            const lrXAxis = lrSvg.append("g")
                .attr("transform", `translate(0, ${lrConfig.mainChart.height - lrConfig.mainChart.margin.bottom})`)
                .call(d3.axisBottom(lrXScale));
                
            const lrYAxis = lrSvg.append("g")
                .attr("transform", `translate(${lrConfig.mainChart.margin.left}, 0)`)
                .call(d3.axisLeft(lrYScale));
                
            // Add axis labels
            lrSvg.append("text")
                .attr("text-anchor", "middle")
                .attr("x", lrConfig.mainChart.width / 2)
                .attr("y", lrConfig.mainChart.height - 10)
                .text("X");
                
            lrSvg.append("text")
                .attr("text-anchor", "middle")
                .attr("transform", `translate(${lrConfig.mainChart.margin.left / 3}, ${lrConfig.mainChart.height / 2}) rotate(-90)`)
                .text("Y");

            // Groups for different elements
            const lrPointsGroup = lrSvg.append("g").attr("class", "lr-points");
            const lrLineGroup = lrSvg.append("g").attr("class", "lr-regression-line");
            const lrOptimalLineGroup = lrSvg.append("g").attr("class", "lr-optimal-line");
            const lrResidualsGroup = lrSvg.append("g").attr("class", "lr-residuals");
            const lrSquaresGroup = lrSvg.append("g").attr("class", "lr-squares");
            const lrMeanLinesGroup = lrSvg.append("g").attr("class", "lr-mean-lines");

            // Improved function to generate correlated data with the specified correlation
            function generateLrData(targetCorrelation, n = lrConfig.pointCount) {
                // Generate X values evenly distributed across the range
                const xValues = Array.from({ length: n }, (_, i) => {
                    const proportion = i / (n - 1);
                    // Add some randomness but keep within plot range
                    const x = lrConfig.xRange[0] + proportion * (lrConfig.xRange[1] - lrConfig.xRange[0]) + 
                            (Math.random() - 0.5) * 20;
                    return Math.max(lrConfig.xRange[0] + 5, Math.min(lrConfig.xRange[1] - 5, x));
                });
                
                // Calculate mean and std dev for X
                const meanX = xValues.reduce((sum, x) => sum + x, 0) / n;
                const varX = xValues.reduce((sum, x) => sum + (x - meanX) ** 2, 0) / n;
                const stdDevX = Math.sqrt(varX);
                
                // Generate independent Y values (random normal distribution)
                const independentYValues = Array.from({ length: n }, () => {
                    // Box-Muller transform for normal distribution
                    const u1 = Math.random();
                    const u2 = Math.random();
                    const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                    return z;
                });
                
                // Calculate mean and std dev for independent Y
                const meanIndepY = independentYValues.reduce((sum, y) => sum + y, 0) / n;
                const varIndepY = independentYValues.reduce((sum, y) => sum + (y - meanIndepY) ** 2, 0) / n;
                const stdDevIndepY = Math.sqrt(varIndepY);
                
                // Normalize independent Y values
                const normalizedIndepY = independentYValues.map(y => (y - meanIndepY) / stdDevIndepY);
                
                // Normalize X values
                const normalizedX = xValues.map(x => (x - meanX) / stdDevX);
                
                // Generate correlated Y values
                const yValues = normalizedX.map((nx, i) => {
                    const correlated = targetCorrelation * nx + 
                                    Math.sqrt(1 - targetCorrelation * targetCorrelation) * normalizedIndepY[i];
                                    
                    // Scale back to desired range (centered around 50, std dev around 15)
                    const targetMeanY = 50;
                    const targetStdDevY = 15;
                    return targetMeanY + correlated * targetStdDevY;
                });
                
                // Ensure Y values stay within plot range
                const clampedYValues = yValues.map(y => 
                    Math.max(lrConfig.yRange[0] + 5, Math.min(lrConfig.yRange[1] - 5, y))
                );
                
                // Create final data points
                return xValues.map((x, i) => ({ x, y: clampedYValues[i] }));
            }

            // Calculate predictions based on intercept and slope
            function getLrPrediction(x, intercept, slope) {
                return intercept + slope * x;
            }

            // Calculate sum of squared errors
            function calculateLrSSE(data, intercept, slope) {
                return data.reduce((sum, point) => {
                    const predicted = getLrPrediction(point.x, intercept, slope);
                    const residual = point.y - predicted;
                    return sum + residual * residual;
                }, 0);
            }

            // Calculate Standard Error of Estimate (SEE)
            function calculateLrSEE(data, intercept, slope) {
                const sse = calculateLrSSE(data, intercept, slope);
                const n = data.length;
                // Standard Error of Estimate formula: sqrt(SSE/(n-2))
                return Math.sqrt(sse / (n - 2));
            }

            // Function to download data as CSV
            function downloadLrCSV() {
                // Create CSV content
                let csvContent = "X,Y\n";
                lrData.forEach(point => {
                    csvContent += `${point.x.toFixed(2)},${point.y.toFixed(2)}\n`;
                });
                
                // Create download link
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                
                // Set up download attributes
                link.setAttribute('href', url);
                link.setAttribute('download', 'regression_data.csv');
                link.style.visibility = 'hidden';
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            // Calculate optimal parameters using least squares
            function calculateLrOptimalParams(data) {
                const n = data.length;
                
                const sumX = data.reduce((sum, p) => sum + p.x, 0);
                const sumY = data.reduce((sum, p) => sum + p.y, 0);
                const sumXY = data.reduce((sum, p) => sum + p.x * p.y, 0);
                const sumXX = data.reduce((sum, p) => sum + p.x * p.x, 0);
                
                const meanX = sumX / n;
                const meanY = sumY / n;
                
                const slope = (sumXY - sumX * sumY / n) / (sumXX - sumX * sumX / n);
                const intercept = meanY - slope * meanX;
                
                return { intercept, slope };
            }

            // Update residuals and squares
            function updateLrResidualsAndSquares() {
                lrResidualsGroup.selectAll("line").remove();
                lrSquaresGroup.selectAll("rect").remove();
                
                if (!lrShowResiduals && !lrShowSquares) {
                    return;
                }
                
                lrData.forEach(point => {
                    const predicted = getLrPrediction(point.x, lrIntercept, lrSlope);
                    const residual = point.y - predicted;
                    
                    if (lrShowResiduals) {
                        lrResidualsGroup.append("line")
                            .attr("x1", lrXScale(point.x))
                            .attr("y1", lrYScale(point.y))
                            .attr("x2", lrXScale(point.x))
                            .attr("y2", lrYScale(predicted))
                            .attr("stroke", "rgba(121, 80, 242, 0.8)")
                            .attr("stroke-width", 1.5)
                            .attr("stroke-dasharray", "4,3");
                    }
                    
                    if (lrShowSquares) {
                        const rectWidth = Math.abs(lrXScale(point.x) - lrXScale(point.x + Math.abs(residual) * Math.sign(residual)));
                        const rectHeight = Math.abs(lrYScale(predicted) - lrYScale(point.y));
                        
                        lrSquaresGroup.append("rect")
                            .attr("x", lrXScale(point.x))
                            .attr("y", residual > 0 ? lrYScale(point.y) : lrYScale(predicted))
                            .attr("width", rectWidth)
                            .attr("height", rectHeight)
                            .attr("fill", "rgba(249, 199, 79, 0.4)")
                            .attr("stroke", "#f9c74f")
                            .attr("stroke-width", 1.5);
                    }
                });
            }

            // Calculate correlation coefficient (r)
            function calculateLrCorrelation(data) {
                const n = data.length;
                
                const sumX = data.reduce((sum, p) => sum + p.x, 0);
                const sumY = data.reduce((sum, p) => sum + p.y, 0);
                const sumXY = data.reduce((sum, p) => sum + p.x * p.y, 0);
                const sumXX = data.reduce((sum, p) => sum + p.x * p.x, 0);
                const sumYY = data.reduce((sum, p) => sum + p.y * p.y, 0);
                
                const numerator = n * sumXY - sumX * sumY;
                const denominator = Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));
                
                return numerator / denominator;
            }
            
            // Calculate coefficient of determination (r²) for given parameters
            function calculateLrRSquared(data, intercept, slope) {
                const meanY = data.reduce((sum, p) => sum + p.y, 0) / data.length;
                
                // Total sum of squares (proportional to variance of y)
                const totalSS = data.reduce((sum, p) => sum + Math.pow(p.y - meanY, 2), 0);
                
                // Residual sum of squares
                const residualSS = calculateLrSSE(data, intercept, slope);
                
                // R-squared = 1 - (residual sum of squares) / (total sum of squares)
                return 1 - (residualSS / totalSS);
            }
            
            // Calculate means of the data
            function calculateLrMeans(data) {
                const meanX = d3.mean(data, d => d.x);
                const meanY = d3.mean(data, d => d.y);
                return { meanX, meanY };
            }
            
            // Update mean lines
            function updateLrMeanLines() {
                // Remove all previous mean lines and text
                lrMeanLinesGroup.selectAll("*").remove();
                
                if (!lrShowMeanLines) return;
                
                const { meanX, meanY } = calculateLrMeans(lrData);
                
                // Add vertical mean line (for X)
                lrMeanLinesGroup.append("line")
                    .attr("x1", lrXScale(meanX))
                    .attr("y1", lrYScale(lrConfig.yRange[0]))
                    .attr("x2", lrXScale(meanX))
                    .attr("y2", lrYScale(lrConfig.yRange[1]))
                    .attr("stroke", "#4361ee")
                    .attr("class", "lr-mean-line");
                
                // Add horizontal mean line (for Y)
                lrMeanLinesGroup.append("line")
                    .attr("x1", lrXScale(lrConfig.xRange[0]))
                    .attr("y1", lrYScale(meanY))
                    .attr("x2", lrXScale(lrConfig.xRange[1]))
                    .attr("y2", lrYScale(meanY))
                    .attr("stroke", "#4361ee")
                    .attr("class", "lr-mean-line");
                    
                // Add text labels for the means
                lrMeanLinesGroup.append("text")
                    .attr("x", lrXScale(meanX) + 5)
                    .attr("y", lrYScale(lrConfig.yRange[0]) - 10)
                    .attr("fill", "#4361ee")
                    .attr("text-anchor", "middle")
                    .text(`x̄ = ${meanX.toFixed(1)}`);
                    
                lrMeanLinesGroup.append("text")
                    .attr("x", lrXScale(lrConfig.xRange[0]) + 40)
                    .attr("y", lrYScale(meanY) - 5)
                    .attr("fill", "#4361ee")
                    .attr("text-anchor", "start")
                    .text(`ȳ = ${meanY.toFixed(1)}`);
            }

            // Update equation displays
            function updateLrEquationDisplay() {
                // Calculate actual correlation and r-squared values
                const actualCorrelation = calculateLrCorrelation(lrData);
                const currentSEE = calculateLrSEE(lrData, lrIntercept, lrSlope);
                const optimalRSquared = calculateLrRSquared(lrData, lrOptimalParams.intercept, lrOptimalParams.slope);
                const optimalSEE = calculateLrSEE(lrData, lrOptimalParams.intercept, lrOptimalParams.slope);
                
                // Current equation (with red color and only SEE value)
                const sign = lrSlope >= 0 ? "+" : "";
                d3.select("#lr-equation-display")
                    .text(`y = ${lrSlope.toFixed(2)}x ${sign} ${lrIntercept.toFixed(1)} (SEE = ${currentSEE.toFixed(2)})`);
                
                // Optimal equation with r, r² and SEE
                const optSign = lrOptimalParams.slope >= 0 ? "+" : "";
                d3.select("#lr-optimal-equation-display").text(
                    `Optimal: y = ${lrOptimalParams.slope.toFixed(2)}x ${optSign} ${lrOptimalParams.intercept.toFixed(1)} (r = ${actualCorrelation.toFixed(2)}, r² = ${optimalRSquared.toFixed(2)}, SEE = ${optimalSEE.toFixed(2)})`
                );
            }
            
            // New function to update the optimal stats section below the chart
            function updateLrOptimalStats() {
                const actualCorrelation = calculateLrCorrelation(lrData);
                const optimalRSquared = calculateLrRSquared(lrData, lrOptimalParams.intercept, lrOptimalParams.slope);
                const optimalSEE = calculateLrSEE(lrData, lrOptimalParams.intercept, lrOptimalParams.slope);
                const optimalSSE = calculateLrSSE(lrData, lrOptimalParams.intercept, lrOptimalParams.slope);
                
                const sign = lrOptimalParams.slope >= 0 ? "+" : "";
                
                // Create a more informative but still compact explanation
                const statsHTML = `
                    <p><strong class="lr-stats-highlight">Optimal Regression Statistics:</strong> y = ${lrOptimalParams.slope.toFixed(2)}x ${sign} ${lrOptimalParams.intercept.toFixed(1)}</p>
                    <p><strong>r = ${actualCorrelation.toFixed(2)}</strong> (${getCorrelationInterpretation(actualCorrelation)}) | 
                    <strong>r² = ${optimalRSquared.toFixed(2)}</strong> (${(optimalRSquared * 100).toFixed(1)}% of Y variation explained)</p>
                    <p><strong>SEE = ${optimalSEE.toFixed(2)}</strong> (average distance of points from line) | 
                    <strong>SSE = ${optimalSSE.toFixed(1)}</strong> (sum of squared errors, minimized by optimal line)</p>
                `;
                
                d3.select("#lr-optimal-stats").html(statsHTML);
            }
            
            // Helper function to interpret correlation strength
            function getCorrelationInterpretation(r) {
                const absR = Math.abs(r);
                if (absR > 0.9) return r > 0 ? "Very strong positive relationship" : "Very strong negative relationship";
                if (absR > 0.7) return r > 0 ? "Strong positive relationship" : "Strong negative relationship";
                if (absR > 0.5) return r > 0 ? "Moderate positive relationship" : "Moderate negative relationship";
                if (absR > 0.3) return r > 0 ? "Weak positive relationship" : "Weak negative relationship";
                return "Little to no linear relationship";
            }

            // Update the main chart
            function updateLrMainChart() {
                // Update equation display
                updateLrEquationDisplay();
                
                // Update data points
                const pointsSelection = lrPointsGroup.selectAll("circle")
                    .data(lrData);
                    
                pointsSelection.enter()
                    .append("circle")
                    .merge(pointsSelection)
                    .attr("cx", d => lrXScale(d.x))
                    .attr("cy", d => lrYScale(d.y))
                    .attr("r", 6)
                    .attr("fill", "rgba(67, 97, 238, 0.7)")
                    .attr("stroke", "#4361ee")
                    .attr("stroke-width", 1)
                    .on("mouseover", function(event, d) {
                        d3.select(this)
                            .attr("fill", "rgba(239, 71, 111, 0.9)")
                            .attr("r", 8)
                            .attr("stroke", "#ef476f")
                            .attr("stroke-width", 2);
                        lrTooltip.style("opacity", 0.9)
                            .html(
                                `<strong>X:</strong> ${d.x.toFixed(1)}<br>` +
                                `<strong>Y:</strong> ${d.y.toFixed(1)}<br>` +
                                `<strong>Residual:</strong> ${(d.y - getLrPrediction(d.x, lrIntercept, lrSlope)).toFixed(2)}`
                            )
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this)
                            .attr("fill", "rgba(67, 97, 238, 0.7)")
                            .attr("r", 6)
                            .attr("stroke", "#4361ee")
                            .attr("stroke-width", 1);
                        lrTooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });
                    
                pointsSelection.exit().remove();
                
                // Update regression line
                lrLineGroup.selectAll("line").remove();
                if (lrShowLine) {
                    const lineX1 = lrConfig.xRange[0];
                    const lineY1 = getLrPrediction(lineX1, lrIntercept, lrSlope);
                    const lineX2 = lrConfig.xRange[1];
                    const lineY2 = getLrPrediction(lineX2, lrIntercept, lrSlope);
                    
                    lrLineGroup.append("line")
                        .attr("x1", lrXScale(lineX1))
                        .attr("y1", lrYScale(lineY1))
                        .attr("x2", lrXScale(lineX2))
                        .attr("y2", lrYScale(lineY2))
                        .attr("stroke", "#ef476f")
                        .attr("stroke-width", 3);
                }
                
                // Calculate current SSE
                const currentSSE = calculateLrSSE(lrData, lrIntercept, lrSlope);
                lrSvg.selectAll(".lr-sse-text").remove();
                lrSvg.append("text")
                    .attr("class", "lr-sse-text")
                    .attr("x", lrConfig.mainChart.width - lrConfig.mainChart.margin.right - 120)
                    .attr("y", lrConfig.mainChart.margin.top + 20)
                    .attr("font-weight", "bold")
                    .text(`SSE: ${currentSSE.toFixed(0)}`);
                    
                // Always calculate and show optimal SSE for comparison
                const optimalSSE = calculateLrSSE(lrData, lrOptimalParams.intercept, lrOptimalParams.slope);
                lrSvg.append("text")
                    .attr("class", "lr-sse-text")
                    .attr("x", lrConfig.mainChart.width - lrConfig.mainChart.margin.right - 120)
                    .attr("y", lrConfig.mainChart.margin.top + 40)
                    .attr("fill", "#2dc653")
                    .attr("font-weight", "bold")
                    .text(`Optimal SSE: ${optimalSSE.toFixed(0)}`);
                    
                // Update optimal line
                lrOptimalLineGroup.selectAll("line").remove();
                if (lrShowOptimalLine) {
                    const optLineX1 = lrConfig.xRange[0];
                    const optLineY1 = getLrPrediction(optLineX1, lrOptimalParams.intercept, lrOptimalParams.slope);
                    const optLineX2 = lrConfig.xRange[1];
                    const optLineY2 = getLrPrediction(optLineX2, lrOptimalParams.intercept, lrOptimalParams.slope);
                    
                    lrOptimalLineGroup.append("line")
                        .attr("x1", lrXScale(optLineX1))
                        .attr("y1", lrYScale(optLineY1))
                        .attr("x2", lrXScale(optLineX2))
                        .attr("y2", lrYScale(optLineY2))
                        .attr("stroke", "#2dc653")
                        .attr("stroke-width", 3)
                        .attr("stroke-dasharray", "6,4");
                }
                
                // Update residuals and squares
                updateLrResidualsAndSquares();
                
                // Update mean lines
                updateLrMeanLines();
                
                // Update the detailed stats section
                updateLrOptimalStats();
            }

            // Function to handle window resize events
            function handleResize() {
                const containerWidth = d3.select("#lr-scatter-plot").node().getBoundingClientRect().width;
                if (containerWidth > 0) {  // Ensure container is visible
                    // Update the svg's viewBox if needed for better scaling
                    lrSvg.attr("viewBox", `0 0 ${lrConfig.mainChart.width} ${lrConfig.mainChart.height}`);
                    // Redraw the chart
                    updateLrMainChart();
                }
            }
            
            // Add window resize event listener
            window.addEventListener("resize", handleResize);

            // Initialize the visualization
            function initLr() {
                // Generate data and calculate optimal parameters
                lrData = generateLrData(lrCorrelation);
                lrOptimalParams = calculateLrOptimalParams(lrData);
                
                // Initialize sliders with optimal values
                lrIntercept = lrOptimalParams.intercept;
                lrSlope = lrOptimalParams.slope;
                
                // Update slider values in the DOM
                d3.select("#lr-intercept").property("value", lrIntercept);
                d3.select("#lr-slope").property("value", lrSlope);
                
                // Update main chart
                updateLrMainChart();
                
                // Update value displays
                d3.select("#lr-correlation-value").text(lrCorrelation.toFixed(2));
                d3.select("#lr-intercept-value").text(lrIntercept.toFixed(1));
                d3.select("#lr-slope-value").text(lrSlope.toFixed(2));
                
                // Display optimal values
                d3.select("#lr-optimal-intercept-value").text(` (opt: ${lrOptimalParams.intercept.toFixed(1)})`);
                d3.select("#lr-optimal-slope-value").text(` (opt: ${lrOptimalParams.slope.toFixed(2)})`);
                
                // Update button text to reflect current state
                d3.select("#lr-show-optimal").text("Hide Optimal Line");
                
                // Make sure the container is properly sized
                handleResize();
            }

            // Set up event listeners
            d3.select("#lr-correlation").on("input", function() {
                lrCorrelation = +this.value;
                d3.select("#lr-correlation-value").text(lrCorrelation.toFixed(2));
                lrData = generateLrData(lrCorrelation);
                lrOptimalParams = calculateLrOptimalParams(lrData);
                
                // Update optimal values display
                d3.select("#lr-optimal-intercept-value").text(` (opt: ${lrOptimalParams.intercept.toFixed(1)})`);
                d3.select("#lr-optimal-slope-value").text(` (opt: ${lrOptimalParams.slope.toFixed(2)})`);
                
                updateLrMainChart();
            });

            d3.select("#lr-intercept").on("input", function() {
                lrIntercept = +this.value;
                d3.select("#lr-intercept-value").text(lrIntercept.toFixed(1));
                updateLrMainChart();
            });

            d3.select("#lr-slope").on("input", function() {
                lrSlope = +this.value;
                d3.select("#lr-slope-value").text(lrSlope.toFixed(2));
                updateLrMainChart();
            });
            
            d3.select("#lr-toggle-line").on("click", function() {
                lrShowLine = !lrShowLine;
                this.innerHTML = lrShowLine ? "Hide Regression Line" : "Show Regression Line";
                updateLrMainChart();
            });

            d3.select("#lr-generate-data").on("click", function() {
                lrData = generateLrData(lrCorrelation);
                lrOptimalParams = calculateLrOptimalParams(lrData);
                
                // Reset sliders to optimal values
                lrIntercept = lrOptimalParams.intercept;
                lrSlope = lrOptimalParams.slope;
                
                // Update slider values in the DOM
                d3.select("#lr-intercept").property("value", lrIntercept);
                d3.select("#lr-slope").property("value", lrSlope);
                
                // Update main chart
                updateLrMainChart();
                
                // Update value displays
                d3.select("#lr-intercept-value").text(lrIntercept.toFixed(1));
                d3.select("#lr-slope-value").text(lrSlope.toFixed(2));
                
                // Update optimal values display
                d3.select("#lr-optimal-intercept-value").text(` (opt: ${lrOptimalParams.intercept.toFixed(1)})`);
                d3.select("#lr-optimal-slope-value").text(` (opt: ${lrOptimalParams.slope.toFixed(2)})`);
            });

            d3.select("#lr-show-residuals").on("click", function() {
                lrShowResiduals = !lrShowResiduals;
                this.innerHTML = lrShowResiduals ? "Hide Residuals" : "Show Residuals";
                lrShowSquares = false;
                d3.select("#lr-show-squares").html("Show Squared Errors");
                updateLrResidualsAndSquares();
            });

            d3.select("#lr-show-squares").on("click", function() {
                lrShowSquares = !lrShowSquares;
                this.innerHTML = lrShowSquares ? "Hide Squared Errors" : "Show Squared Errors";
                if (lrShowSquares) {
                    lrShowResiduals = true;
                    d3.select("#lr-show-residuals").html("Hide Residuals");
                }
                updateLrResidualsAndSquares();
            });

            d3.select("#lr-show-optimal").on("click", function() {
                lrShowOptimalLine = !lrShowOptimalLine;
                this.innerHTML = lrShowOptimalLine ? "Hide Optimal Line" : "Show Optimal Line";
                updateLrMainChart();
            });
            
            d3.select("#lr-show-means").on("click", function() {
                lrShowMeanLines = !lrShowMeanLines;
                this.innerHTML = lrShowMeanLines ? "Hide Mean Lines" : "Show Mean Lines";
                updateLrMeanLines();
            });
            
            d3.select("#lr-download-csv").on("click", function() {
                downloadLrCSV();
            });

            // Initialize the visualization
            initLr();
        })(); // End of IIFE
    </script>
</div>
</div>
</div>
</div>
<p><br></p>
</section>
</section>
<section id="practical-procedures-part-1" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="practical-procedures-part-1"><span class="header-section-number">3.4</span> Practical Procedures (PART 1)</h2>
<ol type="1">
<li>Your tutor will put you into groups of 3.</li>
<li>We are looking for individuals who think they could participate in at least two of the test mentioned above.</li>
<li>During the 3-4 minute sub maximal task, you will track the individual Heart Rate at the end of each minute and their HR at the end of 1 minute resting HR</li>
<li>You will additionally track there HR recovery or the heart rate after resting 60 seconds.</li>
</ol>
<p>Enter data into the Google form that will be provided on VUWS.</p>
<p><a href="https://docs.google.com/forms/d/1le3rZQVx7EUl6UI5dluZLv0H_IiBPgPZBZsqm8JeyxU/preview" class="uri">https://docs.google.com/forms/d/1le3rZQVx7EUl6UI5dluZLv0H_IiBPgPZBZsqm8JeyxU/preview</a> <br></p>
<ol type="1">
<li><p><strong>4 minute run test</strong>: this is done at speed of 8.5km.hr on the treadmill. (If the participants heart rate is below 100 at 2 minutes in, you may raise the speed to 9km.hr for the final two minutes)</p></li>
<li><p><strong>YMCA step test</strong>: download a metronome app and set it 96 BPM, <a href="https://www.metronomeonline.com/" class="uri">https://www.metronomeonline.com/</a></p></li>
</ol>
<ul>
<li>Set the metronome to 96 beats per minute and turn the volume up loud enough that you can hear each beat.</li>
<li>Stand facing your step.</li>
<li>When ready to begin start the stopwatch or timer and begin stepping on and off the step to the metronome beat following a cadence of up, up, down, down.</li>
<li>Continue for 3 minutes.</li>
<li>As soon as you reach 3 minutes, stop immediately and sit down.</li>
</ul>
<ol start="3" type="1">
<li><p><strong>4 minute Monark Bike test</strong>: Cycle at 60 RPM and KP of 1.5 for 4 minutes. If at 2minutes the heart rate is below 100, increase speed to 70 RPM.</p>
<p>If for any reason you feel faint or ill during any of testing it is fine to stop.<br>
<br></p></li>
</ol>
</section>
<section id="reflection" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="reflection"><span class="header-section-number">3.5</span> Reflection</h2>
<p>How could have we better controlled for potential sources of noise/error in the testing procedure we did today?</p>
<p>Why would using a Bland-Altman plot not be appropriate to compare HR’s in this situation?</p>
<p><br></p>
</section>
<section id="section-2---bland-altman-plot" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="section-2---bland-altman-plot"><span class="header-section-number">3.6</span> Section 2 - Bland Altman plot</h2>
<p>In week 3 practical we introduced the Bland-Altman plot, we then discussed use of this plot in more detail in the Week 4 seminar.</p>
<p>Similar to previous weeks you will now have time to practise making a Bland-Altman plot.</p>
<p>Download data from the below tab, and use the excel document used in this weeks seminar(1hr and 2minutes in) to see if you can replicate the results.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Seminar content">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Seminar content
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/-dabHxo1dU4" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
</div>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled" title="Click for interactive Bland-Altman Plot">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Click for interactive Bland-Altman Plot
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div class="ba-container">
    <style>
        .ba-container {
            max-width: 1000px;
            margin: 0 auto;
            font-family: Arial, sans-serif;
        }
        .ba-controls {
            margin: 20px 0;
        }
        .ba-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .ba-sliders {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
        }
        .ba-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 280px;
        }
        .ba-slider-label {
            min-width: 120px;
            display: flex;
            justify-content: space-between;
        }
        .ba-reference-line {
            stroke-dasharray: 5,5;
        }
        .ba-regression-line {
            stroke: green;
            stroke-width: 2;
        }
        .ba-tooltip {
            position: absolute;
            padding: 8px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .ba-radio-container {
            margin: 10px 0;
        }
        .ba-regression-stats {
            margin: 10px 0;
            font-size: 0.9em;
            color: #666;
        }
        .ba-download-btn {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 8px 16px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 10px 0;
            cursor: pointer;
            border-radius: 4px;
        }
        .ba-download-btn:hover {
            background-color: #45a049;
        }
    </style>

    <h4 class="anchored">Interactive Bland-Altman Plot</h4>
    <div class="ba-controls">
        <div class="ba-sliders">
            <div class="ba-slider-container">
                <span class="ba-slider-label">Fixed Bias: <span id="ba-biasValue">0</span></span>
                <input type="range" id="ba-biasSlider" min="-5" max="5" step="0.1" value="0">
            </div>
            <div class="ba-slider-container">
                <span class="ba-slider-label">LOA Width: <span id="ba-loaValue">2</span></span>
                <input type="range" id="ba-loaSlider" min="0.5" max="10" step="0.1" value="2">
            </div>
            <div class="ba-slider-container">
                <span class="ba-slider-label">Proportional Bias: <span id="ba-propBiasValue">0</span></span>
                <input type="range" id="ba-propBiasSlider" min="-0.5" max="0.5" step="0.01" value="0">
            </div>
            <div class="ba-slider-container">
                <span class="ba-slider-label">Heteroscedasticity: <span id="ba-heteroValue">0</span></span>
                <input type="range" id="ba-heteroSlider" min="0" max="0.5" step="0.01" value="0">
            </div>
        </div>
        <div class="ba-radio-container">
            <label>
                <input type="checkbox" id="ba-regressionToggle">
                Show Regression Line (for Proportional Bias)
            </label>
        </div>
        <div id="ba-regressionStats" class="ba-regression-stats"></div>
        <button id="ba-downloadData" class="ba-download-btn">Download Data</button>
    </div>
    <div id="ba-plot"></div>

    <script>
        // Set up dimensions
        const margin = {top: 40, right: 100, bottom: 60, left: 60};
        const width = 550 - margin.left - margin.right;
        const height = 500 - margin.top - margin.bottom;

        // Create SVG
        const svg = d3.select("#ba-plot")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Add tooltip
        const tooltip = d3.select(".ba-container").append("div")
            .attr("class", "ba-tooltip");

        // Calculate linear regression
        function linearRegression(data) {
            const xMean = d3.mean(data, d => d.mean);
            const yMean = d3.mean(data, d => d.diff);
            
            const ssxy = d3.sum(data, d => (d.mean - xMean) * (d.diff - yMean));
            const ssxx = d3.sum(data, d => (d.mean - xMean) * (d.mean - xMean));
            
            const slope = ssxy / ssxx;
            const intercept = yMean - slope * xMean;
            
            // Calculate R-squared
            const yPred = data.map(d => slope * d.mean + intercept);
            const ssTot = d3.sum(data, d => Math.pow(d.diff - yMean, 2));
            const ssRes = d3.sum(data.map((d, i) => Math.pow(d.diff - yPred[i], 2)));
            const rSquared = 1 - (ssRes / ssTot);
            
            return { slope, intercept, rSquared };
        }

        // Generate initial random data
        function generateInitialData(n = 100) {
            return Array.from({length: n}, (_, i) => {
                const methodA = 10 + 2 * (Math.random() - 0.5) * 5;
                const baseDiff = (Math.random() - 0.5) * 2;
                
                return {
                    id: i,
                    methodA: methodA,
                    baseDiff: baseDiff,
                    methodB: methodA + baseDiff,
                    mean: (methodA + methodA + baseDiff) / 2,
                    diff: baseDiff
                };
            });
        }

        // Transform data based on slider values
        function updateData(data, bias, loa, propBias, hetero) {
            return data.map(d => {
                // Apply proportional bias
                const proportionalComponent = propBias * d.methodA;
                
                // Apply heteroscedasticity - variance increases with value
                const heteroscedasticity = hetero * d.methodA * (Math.random() - 0.5);
                
                // Calculate new difference with fixed bias, proportional bias, and heteroscedasticity
                const scaledBaseDiff = d.baseDiff * loa;
                const newDiff = scaledBaseDiff + bias + proportionalComponent + heteroscedasticity;
                
                // Calculate new method B value
                const methodB = d.methodA + newDiff;
                
                return {
                    ...d,
                    methodB: methodB,
                    mean: (d.methodA + methodB) / 2,
                    diff: newDiff
                };
            });
        }

        // Set up scales
        const x = d3.scaleLinear().range([0, width]);
        const y = d3.scaleLinear().range([height, 0])
            .domain([-10, 10]); // Fixed y-axis range

        // Add axes
        const xAxis = svg.append("g")
            .attr("transform", `translate(0,${height})`);
        const yAxis = svg.append("g");

        // Add axis labels
        svg.append("text")
            .attr("text-anchor", "middle")
            .attr("x", width/2)
            .attr("y", height + 40)
            .text("Mean of Methods");

        svg.append("text")
            .attr("text-anchor", "middle")
            .attr("transform", "rotate(-90)")
            .attr("y", -40)
            .attr("x", -height/2)
            .text("Difference (B-A)");

        // Add reference lines
        const meanLine = svg.append("line")
            .attr("class", "ba-reference-line")
            .style("stroke", "red");
                            
        const upperLOA = svg.append("line")
            .attr("class", "ba-reference-line")
            .style("stroke", "blue");
                          
        const lowerLOA = svg.append("line")
            .attr("class", "ba-reference-line")
            .style("stroke", "blue");
                              
        const zeroLine = svg.append("line")
            .attr("class", "ba-reference-line")
            .style("stroke", "#111")
            .style("stroke-width", "1px")
            .style("stroke-dasharray", "3,3");
        
        const regressionLine = svg.append("line")
            .attr("class", "ba-regression-line")
            .style("opacity", 0);

        // Add reference line labels
        const meanLabel = svg.append("text")
            .attr("x", width + 5)
            .style("fill", "red")
            .attr("dominant-baseline", "middle");

        const upperLabel = svg.append("text")
            .attr("x", width + 5)
            .style("fill", "blue")
            .attr("dominant-baseline", "middle");

        const lowerLabel = svg.append("text")
            .attr("x", width + 5)
            .style("fill", "blue")
            .attr("dominant-baseline", "middle");

        // Generate initial data
        let baseData = generateInitialData();
        let currentData = updateData(baseData, 0, 2, 0, 0);

        // Update plot function
        function updatePlot(data) {
            // Update x scale only (y scale is fixed)
            x.domain([d3.min(data, d => d.mean) - 1, d3.max(data, d => d.mean) + 1]);

            // Update axes
            xAxis.call(d3.axisBottom(x));
            yAxis.call(d3.axisLeft(y));

            // Update or create points
            const points = svg.selectAll("circle")
                .data(data, d => d.id);

            points.enter()
                .append("circle")
                .attr("r", 4)
                .style("fill", "steelblue")
                .style("opacity", 0.6)
                .on("mouseover", function(event, d) {
                    d3.select(this)
                        .style("opacity", 1)
                        .attr("r", 6);
                    
                    tooltip.style("opacity", 1)
                        .html(`Method A: ${d.methodA.toFixed(2)}<br>` +
                              `Method B: ${d.methodB.toFixed(2)}<br>` +
                              `Mean: ${d.mean.toFixed(2)}<br>` +
                              `Difference: ${d.diff.toFixed(2)}`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    d3.select(this)
                        .style("opacity", 0.6)
                        .attr("r", 4);
                    tooltip.style("opacity", 0);
                })
                .merge(points)
                .transition()
                .duration(200)
                .attr("cx", d => x(d.mean))
                .attr("cy", d => y(d.diff));

            // Update reference lines
            const bias = d3.mean(data, d => d.diff);
            const sd = d3.deviation(data, d => d.diff);

            zeroLine
                .transition()
                .duration(0)
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", y(0))
                .attr("y2", y(0));

            meanLine
                .transition()
                .duration(200)
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", y(bias))
                .attr("y2", y(bias));

            upperLOA
                .transition()
                .duration(200)
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", y(bias + 1.96 * sd))
                .attr("y2", y(bias + 1.96 * sd));

            lowerLOA
                .transition()
                .duration(200)
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", y(bias - 1.96 * sd))
                .attr("y2", y(bias - 1.96 * sd));

            // Update regression line if toggled
            if (d3.select("#ba-regressionToggle").property("checked")) {
                const reg = linearRegression(data);
                const x1 = x.domain()[0];
                const x2 = x.domain()[1];
                const y1 = reg.slope * x1 + reg.intercept;
                const y2 = reg.slope * x2 + reg.intercept;

                regressionLine
                    .transition()
                    .duration(200)
                    .style("opacity", 1)
                    .attr("x1", x(x1))
                    .attr("y1", y(y1))
                    .attr("x2", x(x2))
                    .attr("y2", y(y2));

                // Update regression stats
                d3.select("#ba-regressionStats")
                    .html(`Slope: ${reg.slope.toFixed(3)}<br>` +
                          `Intercept: ${reg.intercept.toFixed(3)}<br>` +
                          `R²: ${reg.rSquared.toFixed(3)}`);
            } else {
                regressionLine.style("opacity", 0);
                d3.select("#ba-regressionStats").html("");
            }

            // Update labels
            meanLabel
                .transition()
                .duration(200)
                .attr("y", y(bias))
                .text(`BIAS: ${bias.toFixed(2)}`);

            upperLabel
                .transition()
                .duration(200)
                .attr("y", y(bias + 1.96 * sd))
                .text(`ULOA: ${(bias + 1.96 * sd).toFixed(2)}`);

            lowerLabel
                .transition()
                .duration(200)
                .attr("y", y(bias - 1.96 * sd))
                .text(`LLOA: ${(bias - 1.96 * sd).toFixed(2)}`);
        }

        // Function to download data as CSV
        function downloadCSV(data) {
            // Create CSV content
            const headers = ["id", "methodA", "methodB", "mean", "diff"];
            let csvContent = headers.join(",") + "\n";
            
            data.forEach(d => {
                const row = [
                    d.id,
                    d.methodA.toFixed(4),
                    d.methodB.toFixed(4),
                    d.mean.toFixed(4),
                    d.diff.toFixed(4)
                ];
                csvContent += row.join(",") + "\n";
            });
            
            // Create download link
            const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
            const url = URL.createObjectURL(blob);
            
            // Create temporary link and trigger download
            const link = document.createElement("a");
            link.setAttribute("href", url);
            
            // Generate filename with current parameter values
            const bias = d3.select("#ba-biasValue").text();
            const loa = d3.select("#ba-loaValue").text();
            const propBias = d3.select("#ba-propBiasValue").text();
            const hetero = d3.select("#ba-heteroValue").text();
            link.setAttribute("download", `bland_altman_data_bias${bias}_loa${loa}_prop${propBias}_hetero${hetero}.csv`);
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Initial plot
        updatePlot(currentData);

        // Function to update data based on all slider values
        function updateDataFromSliders() {
            const bias = +d3.select("#ba-biasSlider").property("value");
            const loa = +d3.select("#ba-loaSlider").property("value");
            const propBias = +d3.select("#ba-propBiasSlider").property("value");
            const hetero = +d3.select("#ba-heteroSlider").property("value");
            
            currentData = updateData(baseData, bias, loa, propBias, hetero);
            updatePlot(currentData);
        }

        // Slider event listeners
        d3.select("#ba-biasSlider").on("input", function() {
            const bias = +this.value;
            d3.select("#ba-biasValue").text(bias);
            updateDataFromSliders();
        });

        d3.select("#ba-loaSlider").on("input", function() {
            const loa = +this.value;
            d3.select("#ba-loaValue").text(loa);
            updateDataFromSliders();
        });
        
        d3.select("#ba-propBiasSlider").on("input", function() {
            const propBias = +this.value;
            d3.select("#ba-propBiasValue").text(propBias);
            updateDataFromSliders();
        });
        
        d3.select("#ba-heteroSlider").on("input", function() {
            const hetero = +this.value;
            d3.select("#ba-heteroValue").text(hetero);
            updateDataFromSliders();
        });

        // Regression toggle listener
        d3.select("#ba-regressionToggle").on("change", function() {
            updatePlot(currentData);
        });

        // Download button event listener
        d3.select("#ba-downloadData").on("click", function() {
            downloadCSV(currentData);
        });
    </script>
</div>
</div>
</div>
</div>


</section>

</main> <!-- /main -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>

<script>

/* update total correct if #webex-total_correct exists */
update_total_correct = function() {
  console.log("webex: update total_correct");

  var t = document.getElementsByClassName("webex-total_correct");
  for (var i = 0; i < t.length; i++) {
    p = t[i].parentElement;
    var correct = p.getElementsByClassName("webex-correct").length;
    var solvemes = p.getElementsByClassName("webex-solveme").length;
    var radiogroups = p.getElementsByClassName("webex-radiogroup").length;
    var selects = p.getElementsByClassName("webex-select").length;

    t[i].innerHTML = correct + " of " + (solvemes + radiogroups + selects) + " correct";
  }
}

/* webex-solution button toggling function */
b_func = function() {
  console.log("webex: toggle hide");

  var cl = this.parentElement.classList;
  if (cl.contains('open')) {
    cl.remove("open");
  } else {
    cl.add("open");
  }
}

/* check answers */
check_func = function() {
  console.log("webex: check answers");

  var cl = this.parentElement.classList;
  if (cl.contains('unchecked')) {
    cl.remove("unchecked");
    this.innerHTML = "Hide Answers";
  } else {
    cl.add("unchecked");
    this.innerHTML = "Show Answers";
  }
}

/* function for checking solveme answers */
solveme_func = function(e) {
  console.log("webex: check solveme");

  var real_answers = JSON.parse(this.dataset.answer);
  var my_answer = this.value;
  var cl = this.classList;
  if (cl.contains("ignorecase")) {
    my_answer = my_answer.toLowerCase();
  }
  if (cl.contains("nospaces")) {
    my_answer = my_answer.replace(/ /g, "")
  }

  if (my_answer == "") {
    cl.remove("webex-correct");
    cl.remove("webex-incorrect");
  } else if (real_answers.includes(my_answer)) {
    cl.add("webex-correct");
    cl.remove("webex-incorrect");
  } else {
    cl.add("webex-incorrect");
    cl.remove("webex-correct");
  }

  // match numeric answers within a specified tolerance
  if(this.dataset.tol > 0){
    var tol = JSON.parse(this.dataset.tol);
    var matches = real_answers.map(x => Math.abs(x - my_answer) < tol)
    if (matches.reduce((a, b) => a + b, 0) > 0) {
      cl.add("webex-correct");
    } else {
      cl.remove("webex-correct");
    }
  }

  // added regex bit
  if (cl.contains("regex")){
    answer_regex = RegExp(real_answers.join("|"))
    if (answer_regex.test(my_answer)) {
      cl.add("webex-correct");
    }
  }

  update_total_correct();
}

/* function for checking select answers */
select_func = function(e) {
  console.log("webex: check select");

  var cl = this.classList

  /* add style */
  cl.remove("webex-incorrect");
  cl.remove("webex-correct");
  if (this.value == "answer") {
    cl.add("webex-correct");
  } else if (this.value != "blank") {
    cl.add("webex-incorrect");
  }

  update_total_correct();
}

/* function for checking radiogroups answers */
radiogroups_func = function(e) {
  console.log("webex: check radiogroups");

  var checked_button = document.querySelector('input[name=' + this.id + ']:checked');
  var cl = checked_button.parentElement.classList;
  var labels = checked_button.parentElement.parentElement.children;

  /* get rid of styles */
  for (i = 0; i < labels.length; i++) {
    labels[i].classList.remove("webex-incorrect");
    labels[i].classList.remove("webex-correct");
  }

  /* add style */
  if (checked_button.value == "answer") {
    cl.add("webex-correct");
  } else {
    cl.add("webex-incorrect");
  }

  update_total_correct();
}

window.onload = function() {
  console.log("webex onload");
  /* set up solution buttons */
  var buttons = document.getElementsByTagName("button");

  for (var i = 0; i < buttons.length; i++) {
    if (buttons[i].parentElement.classList.contains('webex-solution')) {
      buttons[i].onclick = b_func;
    }
  }

  var check_sections = document.getElementsByClassName("webex-check");
  console.log("check:", check_sections.length);
  for (var i = 0; i < check_sections.length; i++) {
    check_sections[i].classList.add("unchecked");

    let btn = document.createElement("button");
    btn.innerHTML = "Show Answers";
    btn.classList.add("webex-check-button");
    btn.onclick = check_func;
    check_sections[i].appendChild(btn);

    let spn = document.createElement("span");
    spn.classList.add("webex-total_correct");
    check_sections[i].appendChild(spn);
  }

  /* set up webex-solveme inputs */
  var solveme = document.getElementsByClassName("webex-solveme");

  for (var i = 0; i < solveme.length; i++) {
    /* make sure input boxes don't auto-anything */
    solveme[i].setAttribute("autocomplete","off");
    solveme[i].setAttribute("autocorrect", "off");
    solveme[i].setAttribute("autocapitalize", "off");
    solveme[i].setAttribute("spellcheck", "false");
    solveme[i].value = "";

    /* adjust answer for ignorecase or nospaces */
    var cl = solveme[i].classList;
    var real_answer = solveme[i].dataset.answer;
    if (cl.contains("ignorecase")) {
      real_answer = real_answer.toLowerCase();
    }
    if (cl.contains("nospaces")) {
      real_answer = real_answer.replace(/ /g, "");
    }
    solveme[i].dataset.answer = real_answer;

    /* attach checking function */
    solveme[i].onkeyup = solveme_func;
    solveme[i].onchange = solveme_func;

    $(solveme[i]).after(" <span class='webex-icon'></span>");
  }

  /* set up radiogroups */
  var radiogroups = document.getElementsByClassName("webex-radiogroup");
  for (var i = 0; i < radiogroups.length; i++) {
    radiogroups[i].onchange = radiogroups_func;
  }

  /* set up selects */
  var selects = document.getElementsByClassName("webex-select");
  for (var i = 0; i < selects.length; i++) {
    selects[i].onchange = select_func;
    $(selects[i]).after(" <span class='webex-icon'></span>");
  }

  update_total_correct();
}

</script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Practical2.html" class="pagination-link" aria-label="Week 3 - Practical">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Week 3 - Practical</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Practical4.html" class="pagination-link" aria-label="Week 5 - Practical">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Week 5 - Practical</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>