<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>2&nbsp; Week 3 - Practical – SPRT2002 Prac Book</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Practical3.html" rel="next">
<link href="./Practical1.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-8da5b4427184b79ecddefad3d342027e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="include/webex.css">
<link rel="stylesheet" href="custom.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">SPRT2002 Prac Book</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-practicals" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Practicals</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-practicals">    
        <li>
    <a class="dropdown-item" href="./Practical1.html">
 <span class="dropdown-text">Practical 1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./Practical2.html">
 <span class="dropdown-text">Practical 2</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./Practical3.html">
 <span class="dropdown-text">Practical 3</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./Practical4.html">
 <span class="dropdown-text">Practical 4</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./Practical5.html">
 <span class="dropdown-text">Practical 5</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./Practical6.html">
 <span class="dropdown-text">Practical 6</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./Practical7.html">
 <span class="dropdown-text">Practical 7</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <div class="dropdown">
      <a href="" title="Download" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label="Download"><i class="bi bi-download"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="./SPRT2002-Prac-Book.pdf">
              <i class="bi bi-file-pdf pe-1"></i>
            Download PDF
            </a>
          </li>
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="./SPRT2002-Prac-Book.epub">
              <i class="bi bi-journal pe-1"></i>
            Download ePub
            </a>
          </li>
      </ul>
    </div>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#learning-outcome" id="toc-learning-outcome" class="nav-link active" data-scroll-target="#learning-outcome"><span class="header-section-number">2.1</span> Learning Outcome:</a></li>
  <li><a href="#practical-goals" id="toc-practical-goals" class="nav-link" data-scroll-target="#practical-goals"><span class="header-section-number">2.2</span> Practical Goals:</a></li>
  <li><a href="#example-case-study" id="toc-example-case-study" class="nav-link" data-scroll-target="#example-case-study"><span class="header-section-number">2.3</span> Example case study</a>
  <ul class="collapse">
  <li><a href="#bland-altman-plot" id="toc-bland-altman-plot" class="nav-link" data-scroll-target="#bland-altman-plot"><span class="header-section-number">2.3.1</span> Bland-Altman plot</a></li>
  </ul></li>
  <li><a href="#practical-procedures-part-1" id="toc-practical-procedures-part-1" class="nav-link" data-scroll-target="#practical-procedures-part-1"><span class="header-section-number">2.4</span> Practical Procedures (PART 1)</a>
  <ul class="collapse">
  <li><a href="#practical-procedures-reflection" id="toc-practical-procedures-reflection" class="nav-link" data-scroll-target="#practical-procedures-reflection"><span class="header-section-number">2.4.1</span> Practical Procedures reflection</a></li>
  </ul></li>
  <li><a href="#section-2---typical-error-of-measurement" id="toc-section-2---typical-error-of-measurement" class="nav-link" data-scroll-target="#section-2---typical-error-of-measurement"><span class="header-section-number">2.5</span> Section 2 - Typical Error of Measurement</a>
  <ul class="collapse">
  <li><a href="#visual-1" id="toc-visual-1" class="nav-link" data-scroll-target="#visual-1"><span class="header-section-number">2.5.1</span> Visual 1</a></li>
  <li><a href="#visual-2" id="toc-visual-2" class="nav-link" data-scroll-target="#visual-2"><span class="header-section-number">2.5.2</span> Visual 2</a></li>
  </ul></li>
  <li><a href="#test-your-learning" id="toc-test-your-learning" class="nav-link" data-scroll-target="#test-your-learning"><span class="header-section-number">2.6</span> Test your learning</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Week 3 - Practical</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="learning-outcome" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="learning-outcome"><span class="header-section-number">2.1</span> Learning Outcome:</h2>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
<ol type="1">
<li><p>Understand measurement accuracy concepts and their application to exercise testing and measurement</p></li>
<li><p>Evaluate the feasibility of different tests according to environmental conditions and client characteristics</p></li>
<li><p>Demonstrate basic data processing and analytically techniques</p></li>
</ol>
<p><br></p>
</section>
<section id="practical-goals" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="practical-goals"><span class="header-section-number">2.2</span> Practical Goals:</h2>
<ol type="1">
<li><p>2nd round of data collection for practical report 2</p></li>
<li><p>Practice developing skills at running and collecting commonly used test for vertical power assessment.</p></li>
<li><p>Understand basic intuition and use of bland Altman plots for exercise and sport science. (This will be developed more in seminar content next week)</p></li>
<li><p>Build confidence in analysing reliability based metrics such as typical error (TE), CV<sub>TE</sub>%, minimal detectable change (MDC). (Use lecture notes for help)</p></li>
</ol>
<p><br></p>
</section>
<section id="example-case-study" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="example-case-study"><span class="header-section-number">2.3</span> Example case study</h2>
<p>You are hired by an elite sporting organization to help them decide whether they should invest in the purchase of a force plate ($20,000+). The organization currently has access to a range of other measures that can give indications of vertical jump ($400 to $2000) height but the company they are thinking of purchasing the force plate from has loaned them a force plate for two weeks to test it out.</p>
<p>What are some important factors that you might consider when helping the organization make this decision?</p>
<p><br></p>
<section id="bland-altman-plot" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="bland-altman-plot"><span class="header-section-number">2.3.1</span> Bland-Altman plot</h3>
<p>One of the key ways we look to assess the ability to interchange between testing technologies that are attempting to measure the same trait is use of a Bland-Altman plot.</p>
<p>We will discuss Bland-Altman plots in more detail in the lecture in Week 4 but quite simply all the Bland-Altman plot attempts to show us is the difference between one test compared to another test measuring the same thing/</p>
<p>For example we might compare jump height collected from a force plate and linear position transducer. From this we are interested in knowing the mean difference between measures <strong>(BIAS)</strong> and limits of agreement <strong>(LOA)</strong>. LOA is calculated by looking at the <strong>standard deviation of the differences</strong> between test and multiplying by 2 (technically 1.96).<br>
<br>
The <strong>ULOA</strong> is then <strong>BIAS</strong> + <strong>LOA</strong></p>
<p>and</p>
<p><strong>LLOA</strong> calculated as <strong>BIAS</strong> - <strong>LOA</strong></p>
<div class="callout callout-style-default callout-tip callout-titled" title="Click for interactive Bland-Altman plot">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Click for interactive Bland-Altman plot
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">

<div class="ba-container">
    <style>
        .ba-container {
            max-width: 1000px;
            margin: 0 auto;
            font-family: Arial, sans-serif;
        }
        .ba-controls {
            margin: 20px 0;
        }
        .ba-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .ba-sliders {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
        }
        .ba-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 280px;
        }
        .ba-slider-label {
            min-width: 120px;
            display: flex;
            justify-content: space-between;
        }
        .ba-reference-line {
            stroke-dasharray: 5,5;
        }
        .ba-regression-line {
            stroke: green;
            stroke-width: 2;
        }
        .ba-tooltip {
            position: absolute;
            padding: 8px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .ba-radio-container {
            margin: 10px 0;
        }
        .ba-regression-stats {
            margin: 10px 0;
            font-size: 0.9em;
            color: #666;
        }
        .ba-download-btn {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 8px 16px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 10px 0;
            cursor: pointer;
            border-radius: 4px;
        }
        .ba-download-btn:hover {
            background-color: #45a049;
        }
    </style>

    <h4 class="anchored">Interactive Bland-Altman Plot</h4>
    <div class="ba-controls">
        <div class="ba-sliders">
            <div class="ba-slider-container">
                <span class="ba-slider-label">Fixed Bias: <span id="ba-biasValue">0</span></span>
                <input type="range" id="ba-biasSlider" min="-5" max="5" step="0.1" value="0">
            </div>
            <div class="ba-slider-container">
                <span class="ba-slider-label">LOA Width: <span id="ba-loaValue">2</span></span>
                <input type="range" id="ba-loaSlider" min="0.5" max="10" step="0.1" value="2">
            </div>
            <div class="ba-slider-container">
                <span class="ba-slider-label">Proportional Bias: <span id="ba-propBiasValue">0</span></span>
                <input type="range" id="ba-propBiasSlider" min="-0.5" max="0.5" step="0.01" value="0">
            </div>
            <div class="ba-slider-container">
                <span class="ba-slider-label">Heteroscedasticity: <span id="ba-heteroValue">0</span></span>
                <input type="range" id="ba-heteroSlider" min="0" max="0.5" step="0.01" value="0">
            </div>
        </div>
        <div class="ba-radio-container">
            <label>
                <input type="checkbox" id="ba-regressionToggle">
                Show Regression Line (for Proportional Bias)
            </label>
        </div>
        <div id="ba-regressionStats" class="ba-regression-stats"></div>
        <button id="ba-downloadData" class="ba-download-btn">Download Data</button>
    </div>
    <div id="ba-plot"></div>

    <script>
        // Set up dimensions
        const margin = {top: 40, right: 100, bottom: 60, left: 60};
        const width = 550 - margin.left - margin.right;
        const height = 500 - margin.top - margin.bottom;

        // Create SVG
        const svg = d3.select("#ba-plot")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Add tooltip
        const tooltip = d3.select(".ba-container").append("div")
            .attr("class", "ba-tooltip");

        // Calculate linear regression
        function linearRegression(data) {
            const xMean = d3.mean(data, d => d.mean);
            const yMean = d3.mean(data, d => d.diff);
            
            const ssxy = d3.sum(data, d => (d.mean - xMean) * (d.diff - yMean));
            const ssxx = d3.sum(data, d => (d.mean - xMean) * (d.mean - xMean));
            
            const slope = ssxy / ssxx;
            const intercept = yMean - slope * xMean;
            
            // Calculate R-squared
            const yPred = data.map(d => slope * d.mean + intercept);
            const ssTot = d3.sum(data, d => Math.pow(d.diff - yMean, 2));
            const ssRes = d3.sum(data.map((d, i) => Math.pow(d.diff - yPred[i], 2)));
            const rSquared = 1 - (ssRes / ssTot);
            
            return { slope, intercept, rSquared };
        }

        // Generate initial random data
        function generateInitialData(n = 100) {
            return Array.from({length: n}, (_, i) => {
                const methodA = 10 + 2 * (Math.random() - 0.5) * 5;
                const baseDiff = (Math.random() - 0.5) * 2;
                
                return {
                    id: i,
                    methodA: methodA,
                    baseDiff: baseDiff,
                    methodB: methodA + baseDiff,
                    mean: (methodA + methodA + baseDiff) / 2,
                    diff: baseDiff
                };
            });
        }

        // Transform data based on slider values
        function updateData(data, bias, loa, propBias, hetero) {
            return data.map(d => {
                // Apply proportional bias
                const proportionalComponent = propBias * d.methodA;
                
                // Apply heteroscedasticity - variance increases with value
                const heteroscedasticity = hetero * d.methodA * (Math.random() - 0.5);
                
                // Calculate new difference with fixed bias, proportional bias, and heteroscedasticity
                const scaledBaseDiff = d.baseDiff * loa;
                const newDiff = scaledBaseDiff + bias + proportionalComponent + heteroscedasticity;
                
                // Calculate new method B value
                const methodB = d.methodA + newDiff;
                
                return {
                    ...d,
                    methodB: methodB,
                    mean: (d.methodA + methodB) / 2,
                    diff: newDiff
                };
            });
        }

        // Set up scales
        const x = d3.scaleLinear().range([0, width]);
        const y = d3.scaleLinear().range([height, 0])
            .domain([-10, 10]); // Fixed y-axis range

        // Add axes
        const xAxis = svg.append("g")
            .attr("transform", `translate(0,${height})`);
        const yAxis = svg.append("g");

        // Add axis labels
        svg.append("text")
            .attr("text-anchor", "middle")
            .attr("x", width/2)
            .attr("y", height + 40)
            .text("Mean of Methods");

        svg.append("text")
            .attr("text-anchor", "middle")
            .attr("transform", "rotate(-90)")
            .attr("y", -40)
            .attr("x", -height/2)
            .text("Difference (B-A)");

        // Add reference lines
        const meanLine = svg.append("line")
            .attr("class", "ba-reference-line")
            .style("stroke", "red");
                            
        const upperLOA = svg.append("line")
            .attr("class", "ba-reference-line")
            .style("stroke", "blue");
                          
        const lowerLOA = svg.append("line")
            .attr("class", "ba-reference-line")
            .style("stroke", "blue");
                              
        const zeroLine = svg.append("line")
            .attr("class", "ba-reference-line")
            .style("stroke", "#111")
            .style("stroke-width", "1px")
            .style("stroke-dasharray", "3,3");
        
        const regressionLine = svg.append("line")
            .attr("class", "ba-regression-line")
            .style("opacity", 0);

        // Add reference line labels
        const meanLabel = svg.append("text")
            .attr("x", width + 5)
            .style("fill", "red")
            .attr("dominant-baseline", "middle");

        const upperLabel = svg.append("text")
            .attr("x", width + 5)
            .style("fill", "blue")
            .attr("dominant-baseline", "middle");

        const lowerLabel = svg.append("text")
            .attr("x", width + 5)
            .style("fill", "blue")
            .attr("dominant-baseline", "middle");

        // Generate initial data
        let baseData = generateInitialData();
        let currentData = updateData(baseData, 0, 2, 0, 0);

        // Update plot function
        function updatePlot(data) {
            // Update x scale only (y scale is fixed)
            x.domain([d3.min(data, d => d.mean) - 1, d3.max(data, d => d.mean) + 1]);

            // Update axes
            xAxis.call(d3.axisBottom(x));
            yAxis.call(d3.axisLeft(y));

            // Update or create points
            const points = svg.selectAll("circle")
                .data(data, d => d.id);

            points.enter()
                .append("circle")
                .attr("r", 4)
                .style("fill", "steelblue")
                .style("opacity", 0.6)
                .on("mouseover", function(event, d) {
                    d3.select(this)
                        .style("opacity", 1)
                        .attr("r", 6);
                    
                    tooltip.style("opacity", 1)
                        .html(`Method A: ${d.methodA.toFixed(2)}<br>` +
                              `Method B: ${d.methodB.toFixed(2)}<br>` +
                              `Mean: ${d.mean.toFixed(2)}<br>` +
                              `Difference: ${d.diff.toFixed(2)}`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    d3.select(this)
                        .style("opacity", 0.6)
                        .attr("r", 4);
                    tooltip.style("opacity", 0);
                })
                .merge(points)
                .transition()
                .duration(200)
                .attr("cx", d => x(d.mean))
                .attr("cy", d => y(d.diff));

            // Update reference lines
            const bias = d3.mean(data, d => d.diff);
            const sd = d3.deviation(data, d => d.diff);

            zeroLine
                .transition()
                .duration(0)
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", y(0))
                .attr("y2", y(0));

            meanLine
                .transition()
                .duration(200)
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", y(bias))
                .attr("y2", y(bias));

            upperLOA
                .transition()
                .duration(200)
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", y(bias + 1.96 * sd))
                .attr("y2", y(bias + 1.96 * sd));

            lowerLOA
                .transition()
                .duration(200)
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", y(bias - 1.96 * sd))
                .attr("y2", y(bias - 1.96 * sd));

            // Update regression line if toggled
            if (d3.select("#ba-regressionToggle").property("checked")) {
                const reg = linearRegression(data);
                const x1 = x.domain()[0];
                const x2 = x.domain()[1];
                const y1 = reg.slope * x1 + reg.intercept;
                const y2 = reg.slope * x2 + reg.intercept;

                regressionLine
                    .transition()
                    .duration(200)
                    .style("opacity", 1)
                    .attr("x1", x(x1))
                    .attr("y1", y(y1))
                    .attr("x2", x(x2))
                    .attr("y2", y(y2));

                // Update regression stats
                d3.select("#ba-regressionStats")
                    .html(`Slope: ${reg.slope.toFixed(3)}<br>` +
                          `Intercept: ${reg.intercept.toFixed(3)}<br>` +
                          `R²: ${reg.rSquared.toFixed(3)}`);
            } else {
                regressionLine.style("opacity", 0);
                d3.select("#ba-regressionStats").html("");
            }

            // Update labels
            meanLabel
                .transition()
                .duration(200)
                .attr("y", y(bias))
                .text(`BIAS: ${bias.toFixed(2)}`);

            upperLabel
                .transition()
                .duration(200)
                .attr("y", y(bias + 1.96 * sd))
                .text(`ULOA: ${(bias + 1.96 * sd).toFixed(2)}`);

            lowerLabel
                .transition()
                .duration(200)
                .attr("y", y(bias - 1.96 * sd))
                .text(`LLOA: ${(bias - 1.96 * sd).toFixed(2)}`);
        }

        // Function to download data as CSV
        function downloadCSV(data) {
            // Create CSV content
            const headers = ["id", "methodA", "methodB", "mean", "diff"];
            let csvContent = headers.join(",") + "\n";
            
            data.forEach(d => {
                const row = [
                    d.id,
                    d.methodA.toFixed(4),
                    d.methodB.toFixed(4),
                    d.mean.toFixed(4),
                    d.diff.toFixed(4)
                ];
                csvContent += row.join(",") + "\n";
            });
            
            // Create download link
            const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
            const url = URL.createObjectURL(blob);
            
            // Create temporary link and trigger download
            const link = document.createElement("a");
            link.setAttribute("href", url);
            
            // Generate filename with current parameter values
            const bias = d3.select("#ba-biasValue").text();
            const loa = d3.select("#ba-loaValue").text();
            const propBias = d3.select("#ba-propBiasValue").text();
            const hetero = d3.select("#ba-heteroValue").text();
            link.setAttribute("download", `bland_altman_data_bias${bias}_loa${loa}_prop${propBias}_hetero${hetero}.csv`);
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Initial plot
        updatePlot(currentData);

        // Function to update data based on all slider values
        function updateDataFromSliders() {
            const bias = +d3.select("#ba-biasSlider").property("value");
            const loa = +d3.select("#ba-loaSlider").property("value");
            const propBias = +d3.select("#ba-propBiasSlider").property("value");
            const hetero = +d3.select("#ba-heteroSlider").property("value");
            
            currentData = updateData(baseData, bias, loa, propBias, hetero);
            updatePlot(currentData);
        }

        // Slider event listeners
        d3.select("#ba-biasSlider").on("input", function() {
            const bias = +this.value;
            d3.select("#ba-biasValue").text(bias);
            updateDataFromSliders();
        });

        d3.select("#ba-loaSlider").on("input", function() {
            const loa = +this.value;
            d3.select("#ba-loaValue").text(loa);
            updateDataFromSliders();
        });
        
        d3.select("#ba-propBiasSlider").on("input", function() {
            const propBias = +this.value;
            d3.select("#ba-propBiasValue").text(propBias);
            updateDataFromSliders();
        });
        
        d3.select("#ba-heteroSlider").on("input", function() {
            const hetero = +this.value;
            d3.select("#ba-heteroValue").text(hetero);
            updateDataFromSliders();
        });

        // Regression toggle listener
        d3.select("#ba-regressionToggle").on("change", function() {
            updatePlot(currentData);
        });

        // Download button event listener
        d3.select("#ba-downloadData").on("click", function() {
            downloadCSV(currentData);
        });
    </script>
</div>
</div>
</div>
</div>
<p><br></p>
</section>
</section>
<section id="practical-procedures-part-1" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="practical-procedures-part-1"><span class="header-section-number">2.4</span> Practical Procedures (PART 1)</h2>
<p><br></p>
<ol type="1">
<li><p>Get yourself into groups of 5-7 people. Your tutor will allocate each group to a testing location. The tutor will explain how to use technology and equipment to each group at each testing location once.</p></li>
<li><p>It is then the responsibility of each group to educate the following group on how to successfully perform and run test for each testing station.</p></li>
<li><p>Continue the above until you have completed each testing station.</p></li>
<li><p>Aim to perform at least 2 repetitions per station making sure to upload the results on the Google form link below. (This can be done by one person per group)</p></li>
</ol>
<p><br></p>
<section id="practical-procedures-reflection" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1" class="anchored" data-anchor-id="practical-procedures-reflection"><span class="header-section-number">2.4.1</span> Practical Procedures reflection</h3>
<ol type="1">
<li><p>What were the key differences you noticed between the technologies used?</p></li>
<li><p>Based on your experience using the technologies which technology would you lean towards using and why?</p></li>
</ol>
<p><br></p>
</section>
</section>
<section id="section-2---typical-error-of-measurement" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="section-2---typical-error-of-measurement"><span class="header-section-number">2.5</span> Section 2 - Typical Error of Measurement</h2>
<p>In the following section the aim is to try and calculate the Typical Error (<strong>TE</strong>), <strong>CV<sub>TE</sub>%</strong>, minimal detectable change (<strong>MDC95</strong>).</p>
<p><strong>In the visual below, set the number of trials to 2 and then download the data.</strong></p>
<p>See if you are able to replicate the results in the text box above the visual (hint,the back end of this weeks lecture will help you figure out how to do this)</p>
<section id="visual-1" class="level3" data-number="2.5.1">
<h3 data-number="2.5.1" class="anchored" data-anchor-id="visual-1"><span class="header-section-number">2.5.1</span> Visual 1</h3>
<div class="rel-container" style="font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px;">
    <div id="rel-visualization">
        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <div id="rel-descriptive-stats" style="text-align: left; font-family: monospace; background-color: #f5f5f5; padding: 10px; border-radius: 5px; width: 48%;"></div>
            <div id="rel-reliability-metrics" style="text-align: right; font-family: monospace; background-color: #f5f5f5; padding: 10px; border-radius: 5px; width: 48%;"></div>
        </div>
        <div class="rel-controls-container" style="display: flex; justify-content: space-between; margin-bottom: 20px;">
            <div class="rel-column" style="width: 48%;">
                <div class="rel-slider-container" style="margin-bottom: 10px; display: flex; align-items: center;">
                    <label for="rel-trials-slider" style="width: 180px; margin-right: 10px; font-size: 0.9em;">Number of Trials:</label>
                    <input type="range" id="rel-trials-slider" min="1" max="10" step="1" value="5">
                    <span id="rel-trials-value" style="width: 40px; text-align: right; font-size: 0.9em;"></span>
                </div>
                <div class="rel-slider-container" style="margin-bottom: 10px; display: flex; align-items: center;">
                    <label for="rel-subjects-slider" style="width: 180px; margin-right: 10px; font-size: 0.9em;">Number of Subjects:</label>
                    <input type="range" id="rel-subjects-slider" min="1" max="20" step="1" value="10">
                    <span id="rel-subjects-value" style="width: 40px; text-align: right; font-size: 0.9em;"></span>
                </div>
                <div class="rel-slider-container" style="margin-bottom: 10px; display: flex; align-items: center;">
                    <label for="rel-variation-learning-slider" style="width: 180px; margin-right: 10px; font-size: 0.9em;">Variation Learning Effect:</label>
                    <input type="range" id="rel-variation-learning-slider" min="0" max="1" step="0.1" value="0.5">
                    <span id="rel-variation-learning-value" style="width: 40px; text-align: right; font-size: 0.9em;"></span>
                </div>
            </div>
            <div class="rel-column" style="width: 48%;">
                <div class="rel-slider-container" style="margin-bottom: 10px; display: flex; align-items: center;">
                    <label for="rel-bias-slider" style="width: 180px; margin-right: 10px; font-size: 0.9em;">Systematic Bias (±15 units max):</label>
                    <input type="range" id="rel-bias-slider" min="-15" max="15" step="1" value="0">
                    <span id="rel-bias-value" style="width: 40px; text-align: right; font-size: 0.9em;"></span>
                </div>
                <div class="rel-slider-container" style="margin-bottom: 10px; display: flex; align-items: center;">
                    <label for="rel-learning-slider" style="width: 180px; margin-right: 10px; font-size: 0.9em;">Learning Rate:</label>
                    <input type="range" id="rel-learning-slider" min="0" max="5" step="0.2" value="0">
                    <span id="rel-learning-value" style="width: 40px; text-align: right; font-size: 0.9em;"></span>
                </div>
                <div class="rel-slider-container" style="margin-bottom: 10px; display: flex; align-items: center;">
                    <label for="rel-variation-slider" style="width: 180px; margin-right: 10px; font-size: 0.9em;">Within-subject Variation:</label>
                    <input type="range" id="rel-variation-slider" min="0" max="10" step="0.1" value="5">
                    <span id="rel-variation-value" style="width: 40px; text-align: right; font-size: 0.9em;"></span>
                </div>
            </div>
        </div>

        <div id="rel-chart" style="width: 100%; height: 400px; margin-bottom: 20px;"></div>

        <div class="rel-toggle-container" style="display: flex; justify-content: center; gap: 20px; margin-bottom: 20px;">
            <div class="rel-toggle-group" style="display: flex; align-items: center;">
                <label style="margin-right: 10px; font-size: 0.9em;">Show Group Average:</label>
                <input type="radio" name="rel-group-average" value="show" checked=""> Show
                <input type="radio" name="rel-group-average" value="hide"> Hide
            </div>
            <div class="rel-toggle-group" style="display: flex; align-items: center;">
                <label style="margin-right: 10px; font-size: 0.9em;">Show Individual Paths:</label>
                <input type="radio" name="rel-individual-paths" value="show" checked=""> Show
                <input type="radio" name="rel-individual-paths" value="hide"> Hide
            </div>
            <button id="rel-download-btn" style="padding: 5px 10px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em;">
                Download Data (CSV)
            </button>
        </div>
    </div>

    <script>
        (function() {  // Wrap in IIFE to avoid global scope pollution
            // Set up dimensions
            const margin = {top: 20, right: 30, bottom: 50, left: 60};
            const width = 700 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            // Create SVG
            const svg = d3.select("#rel-chart")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Set up scales
            const x = d3.scaleLinear().range([0, width]);
            const y = d3.scaleLinear().range([height, 0]);
            const color = d3.scaleOrdinal(d3.schemeCategory10);

            // Set up line generator
            const line = d3.line()
                .x((d, i) => x(i + 1))
                .y(d => y(d));

            // Generate initial random components (only done once)
            const maxSubjects = 20;
            const maxTrials = 10;
            const baseJump = 50;

            // Generate stable random components
            const generateStableRandomComponents = () => {
                const components = {
                    baselineValues: [],
                    randomEffects: [],
                    correlationMatrix: []
                };

                // Generate baseline values for each subject
                for (let i = 0; i < maxSubjects; i++) {
                    components.baselineValues.push(baseJump + d3.randomNormal(0, 5)());
                }

                // Generate random effects matrix
                for (let i = 0; i < maxSubjects; i++) {
                    const subjectEffects = [];
                    for (let j = 0; j < maxTrials; j++) {
                        subjectEffects.push(d3.randomNormal(0, 1)());
                    }
                    components.randomEffects.push(subjectEffects);
                }

                // Create correlation matrix for trials
                const correlationMatrix = [];
                for (let i = 0; i < maxTrials; i++) {
                    const row = [];
                    for (let j = 0; j < maxTrials; j++) {
                        const correlation = Math.exp(-0.3 * Math.abs(i - j));
                        row.push(correlation);
                    }
                    correlationMatrix.push(row);
                }
                components.correlationMatrix = correlationMatrix;

                return components;
            };

            // Cholesky decomposition function
            function choleskyDecomposition(matrix) {
                const n = matrix.length;
                const L = Array(n).fill().map(() => Array(n).fill(0));
                
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j <= i; j++) {
                        let sum = 0;
                        
                        if (j === i) {
                            for (let k = 0; k < j; k++) {
                                sum += L[j][k] * L[j][k];
                            }
                            L[j][j] = Math.sqrt(matrix[j][j] - sum);
                        } else {
                            for (let k = 0; k < j; k++) {
                                sum += L[i][k] * L[j][k];
                            }
                            L[i][j] = (matrix[i][j] - sum) / L[j][j];
                        }
                    }
                }
                
                return L;
            }

            // Generate the stable components once
            const stableComponents = generateStableRandomComponents();
            const choleskyMatrix = choleskyDecomposition(stableComponents.correlationMatrix);

            // Function to generate data using stable components
            function generateData(numSubjects, numTrials, bias, initialVariation, learning, variationLearning) {
                const data = [];
                
                for (let i = 0; i < numSubjects; i++) {
                    const subject = [];
                    const baseValue = stableComponents.baselineValues[i];
                    
                    // Transform random effects using Cholesky decomposition
                    const correlatedEffects = new Array(numTrials).fill(0);
                    for (let j = 0; j < numTrials; j++) {
                        for (let k = 0; k <= j; k++) {
                            correlatedEffects[j] += choleskyMatrix[j][k] * stableComponents.randomEffects[i][k];
                        }
                    }

                    // Generate measurements for each trial
                    for (let j = 0; j < numTrials; j++) {
                        const learningProportion = learning === 0 
                            ? j / (numTrials - 1 || 1)
                            : (1 - Math.exp(-learning * 2 * j / (numTrials - 1 || 1))) / (1 - Math.exp(-learning * 2));
                        
                        const systematicBiasEffect = bias * learningProportion;
                        const trialVariation = initialVariation * (1 - variationLearning * (j / numTrials));
                        const measurement = Number((baseValue + systematicBiasEffect + (correlatedEffects[j] * trialVariation)).toFixed(2));
                        subject.push(measurement);
                    }
                    
                    data.push(subject);
                }
                
                return data;
            }

            // Function to calculate reliability metrics
            function calculateReliabilityMetrics(data, numTrials) {
                const trialPairDiffs = Array(numTrials - 1).fill().map(() => []);
                
                for (let subject of data) {
                    for (let i = 0; i < numTrials - 1; i++) {
                        const diff = subject[i + 1] - subject[i];
                        trialPairDiffs[i].push(diff);
                    }
                }
                
                const trialPairSDs = trialPairDiffs.map(diffs => d3.deviation(diffs));
                const rmsSD = Math.sqrt(trialPairSDs.reduce((acc, sd) => acc + sd * sd, 0) / trialPairSDs.length);
                const sem = rmsSD / Math.sqrt(2);
                const mdc = rmsSD * 1.96;
                
                const allMeasurements = data.flat();
                const mean = d3.mean(allMeasurements);
                const cv = (sem / mean) * 100;
                
                return { sem, mdc, cv };
            }

            // Function to calculate descriptive statistics
            function calculateDescriptiveStats(data) {
                const allMeasurements = data.flat();
                const mean = d3.mean(allMeasurements);
                const median = d3.median(allMeasurements);
                const sd = d3.deviation(allMeasurements);
                const min = d3.min(allMeasurements);
                const max = d3.max(allMeasurements);
                const cv = (sd / mean) * 100;
                
                // Calculate by-trial stats
                const trialMeans = [];
                const trialSDs = [];
                
                for (let j = 0; j < data[0].length; j++) {
                    const trialValues = data.map(subject => subject[j]);
                    trialMeans.push(d3.mean(trialValues));
                    trialSDs.push(d3.deviation(trialValues));
                }
                
                return { 
                    mean, 
                    median, 
                    sd, 
                    min, 
                    max, 
                    cv,
                    trialMeans,
                    trialSDs
                };
            }

            // Function to convert data to CSV
            function convertToCSV(data, numTrials) {
                let csvContent = "SubjectID," + Array.from({length: numTrials}, (_, i) => `Trial${i+1}`).join(",") + "\n";
                data.forEach((subject, index) => {
                    csvContent += `Subject${index + 1},` + subject.join(",") + "\n";
                });
                return csvContent;
            }

            // Function to download data as CSV
            function downloadCSV(data, numTrials) {
                const csv = convertToCSV(data, numTrials);
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement("a");
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", "reliability_data.csv");
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            // Initialize chart and data
            let currentData = null;
            let currentNumTrials = null;

            // Function to update chart
            function updateChart() {
                const numTrials = +d3.select("#rel-trials-slider").property("value");
                const numSubjects = +d3.select("#rel-subjects-slider").property("value");
                const bias = +d3.select("#rel-bias-slider").property("value");
                const initialVariation = +d3.select("#rel-variation-slider").property("value");
                const learning = +d3.select("#rel-learning-slider").property("value");
                const variationLearning = +d3.select("#rel-variation-learning-slider").property("value");
                
                const showGroupAverage = d3.select('input[name="rel-group-average"]:checked').property("value") === "show";
                const showIndividualPaths = d3.select('input[name="rel-individual-paths"]:checked').property("value") === "show";
                
                const data = generateData(numSubjects, numTrials, bias, initialVariation, learning, variationLearning);
                
                currentData = data;
                currentNumTrials = numTrials;
                
                const { sem, mdc, cv } = calculateReliabilityMetrics(data, numTrials);
                const stats = calculateDescriptiveStats(data);
                
                // Update reliability metrics with subscript for CV
                d3.select("#rel-reliability-metrics")
                    .html(`<strong>Reliability Metrics:</strong><br>TE = ${sem.toFixed(2)} units<br>MDC = ${mdc.toFixed(2)} units<br>CV<sub>TE</sub> = ${cv.toFixed(2)}%`);
                
                // Update descriptive statistics
                d3.select("#rel-descriptive-stats")
                    .html(`<strong>Descriptive Statistics:</strong><br>Mean = ${stats.mean.toFixed(1)} units<br>SD = ${stats.sd.toFixed(1)} units<br>CV = ${stats.cv.toFixed(1)}%<br>Range = ${stats.min.toFixed(1)} - ${stats.max.toFixed(1)}`);

                // Update scales
                x.domain([0.5, numTrials + 0.5]);
                y.domain([25, 85]);

                // Clear previous elements
                svg.selectAll("*").remove();

                // Add subtle vertical grid lines
                svg.selectAll("line.vertical-grid")
                    .data(d3.range(1, numTrials + 1))
                    .enter()
                    .append("line")
                    .attr("x1", d => x(d))
                    .attr("y1", 0)
                    .attr("x2", d => x(d))
                    .attr("y2", height)
                    .attr("stroke", "#e0e0e0")
                    .attr("stroke-width", 1)
                    .attr("shape-rendering", "crispEdges");

                // Add X axis
                svg.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x).ticks(numTrials).tickFormat(d3.format('d')));

                // Add X axis label
                svg.append("text")
                    .attr("transform", `translate(${width/2}, ${height + 40})`)
                    .style("text-anchor", "middle")
                    .text("Trial Number");

                // Add Y axis
                svg.append("g")
                    .call(d3.axisLeft(y));

                // Add Y axis label
                svg.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 0 - margin.left)
                    .attr("x", 0 - (height / 2))
                    .attr("dy", "1em")
                    .style("text-anchor", "middle")
                    .text("Measured Output");

                if (showIndividualPaths) {
                    // Add lines for each subject
                    svg.selectAll(".rel-line")
                        .data(data)
                        .enter()
                        .append("path")
                        .attr("class", "rel-line")
                        .attr("fill", "none")
                        .attr("stroke", (d, i) => color(i))
                        .attr("stroke-width", 1.5)
                        .attr("d", line);
                }

                if (showGroupAverage) {
                    // Calculate and add mean line
                    const means = d3.range(numTrials).map(i => d3.mean(data, d => d[i]));
                    svg.append("path")
                        .datum(means)
                        .attr("class", "rel-mean-line")
                        .attr("fill", "none")
                        .attr("stroke", "black")
                        .attr("stroke-width", 3)
                        .attr("d", line);

                    // Calculate and add SD area
                    const sds = d3.range(numTrials).map(i => d3.deviation(data, d => d[i]));
                    const areaGenerator = d3.area()
                        .x((d, i) => x(i + 1))
                        .y0(d => y(d[0] - d[1]))
                        .y1(d => y(d[0] + d[1]));

                    svg.append("path")
                        .datum(d3.zip(means, sds))
                        .attr("class", "rel-sd-area")
                        .attr("fill", "rgba(0,0,0,0.1)")
                        .attr("d", areaGenerator);
                }
            }

            // Initial chart render
            updateChart();

            // Update chart when sliders or radio buttons change
            d3.selectAll(".rel-container input").on("input change", function() {
                if (this.type === "range") {
                    d3.select(`#${this.id}-value`).text(this.value);
                }
                updateChart();
            });

            // Initialize slider value displays
            d3.selectAll(".rel-container input[type='range']").each(function() {
                d3.select(`#${this.id}-value`).text(this.value);
            });

            // Add download button event listener
            d3.select("#rel-download-btn").on("click", function() {
                if (currentData && currentNumTrials) {
                    downloadCSV(currentData, currentNumTrials);
                }
            });
        })();
    </script>
</div>
</section>
<section id="visual-2" class="level3" data-number="2.5.2">
<h3 data-number="2.5.2" class="anchored"><span class="header-section-number">2.5.2</span> Visual 2</h3>
<p>The visual below looks to highlight the importance of wanting to minimise Typical Error. You hopefully feel comfortable with the idea that any measurement we collect has some uncertainty around it. That uncertainty may be due to biological variation, technology and or methodology error, which all limit our confidence in reporting a “true” measurement. We aim to represent this uncertainty in a similar fashion to what we did last week with the 95% <strong>Confidence Interval (CI)</strong>.</p>
<p>To calculate the <strong>CI</strong> around the observed scores (point A and B), we use a similar formula that we did last week when we calculated the 95% CI around a sample mean, the only difference being instead of using a standard error, we will use the <strong>Typical Error (TE)</strong>.</p>
<p>For example,</p>
<p>Point A score = 50. For a given value of the Typical Error slider, e.g.&nbsp;3 the 95 % CI would be</p>
<p>50 - (3 <span class="math inline">\(\times\)</span> 1.96) = <strong>44.1</strong> to 50 + (3 <span class="math inline">\(\times\)</span> 1.96) = <strong>55.9</strong></p>
<p>This interval represents our uncertainty around where we believe the true measurement might be. From an interpretation perspective we <strong>can’t</strong> say the probability of the true value being between the lower limit and upper limit is 95%, rather that the method we used to create the interval has a 95% success rate in capturing true values over the long run.</p>
<p>We can also calculate an uncertainty around the change score observed between these two measurements (A and B). Now that we are comparing two measurements that both come with uncertainty we have to adjust our calculation slightly to account for this when calculating a CI for a change score we do so with the equation below.</p>
<p>Change 95% LL = (Point B - Point A observed values) - <span class="math inline">\(\sqrt{2}\)</span> <span class="math inline">\(\times\)</span> TE <span class="math inline">\(\times\)</span> 1.96 Change 95% UL = (Point B - Point A observed values) + <span class="math inline">\(\sqrt{2}\)</span> <span class="math inline">\(\times\)</span> TE <span class="math inline">\(\times\)</span> 1.96</p>
<p>The <span class="math inline">\(\sqrt{2}\)</span> is included because we now have two trials that both have a potential source of uncertainty. The addition of the <span class="math inline">\(\sqrt{2}\)</span> as you can see makes the CI larger for change scores than for individual observations.</p>
<div class="diff-container" style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
  <div id="diff-visualization">
    <h2 style="text-align: center; margin-bottom: 15px;" class="anchored" data-anchor-id="visual-2">Interactive Difference Plot</h2>
    
    <div class="diff-controls-container" style="display: flex; flex-wrap: wrap; justify-content: space-between; margin-bottom: 20px;">
      <div class="diff-slider-container" style="width: 48%; margin-bottom: 10px; display: flex; align-items: center;">
        <label for="diff-change-score-slider" style="width: 120px; margin-right: 10px; font-size: 0.9em;">Change Score:</label>
        <input type="range" id="diff-change-score-slider" min="-30" max="30" step="1" value="-15" style="flex-grow: 1;">
        <span id="diff-change-score-value" style="width: 30px; text-align: right; font-size: 0.9em;"></span>
      </div>
      
      <div class="diff-slider-container" style="width: 48%; margin-bottom: 10px; display: flex; align-items: center;">
        <label for="diff-typical-error-slider" style="width: 120px; margin-right: 10px; font-size: 0.9em;">Typical Error:</label>
        <input type="range" id="diff-typical-error-slider" min="1" max="12" step="1" value="6" style="flex-grow: 1;">
        <span id="diff-typical-error-value" style="width: 30px; text-align: right; font-size: 0.9em;"></span>
      </div>
      
      <div class="diff-slider-container" style="width: 48%; margin-bottom: 10px; display: flex; align-items: center;">
        <label for="diff-between-subject-sd-slider" style="width: 120px; margin-right: 10px; font-size: 0.9em;">Between-Subject SD:</label>
        <input type="range" id="diff-between-subject-sd-slider" min="1" max="20" step="1" value="8" style="flex-grow: 1;">
        <span id="diff-between-subject-sd-value" style="width: 30px; text-align: right; font-size: 0.9em;"></span>
      </div>
      
      <div class="diff-slider-container" style="width: 48%; margin-bottom: 10px; display: flex; align-items: center;">
        <label for="diff-sd-multiplier-slider" style="width: 120px; margin-right: 10px; font-size: 0.9em;">SD Multiplier:</label>
        <input type="range" id="diff-sd-multiplier-slider" min="0.05" max="1.2" step="0.01" value="0.5" style="flex-grow: 1;">
        <span id="diff-sd-multiplier-value" style="width: 30px; text-align: right; font-size: 0.9em;"></span>
      </div>
    </div>
    
    <div style="text-align: center; margin-bottom: 10px; display: flex; justify-content: center; gap: 30px;">
      <label style="font-size: 0.9em;">
        <input type="checkbox" id="diff-show-ci-toggle" checked=""> Show Confidence Intervals
      </label>
      <label style="font-size: 0.9em;">
        <input type="checkbox" id="diff-show-swc-toggle" checked=""> Show SWC
      </label>
      <label style="font-size: 0.9em;">
        <input type="checkbox" id="diff-show-mdc-toggle"> Show MDC Lines
      </label>
      <label style="font-size: 0.9em;">
        <input type="checkbox" id="diff-show-mcid-toggle"> Show MCID Lines
      </label>
    </div>
    
    <div id="diff-chart" style="width: 100%; height: 400px; margin-bottom: 20px;"></div>
    
    <div id="diff-interpretation" style="text-align: center; margin-top: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f9f9f9; border-radius: 4px;">
      <!-- Interpretation text will be inserted here dynamically -->
    </div>
  </div>

  <script>
    (function() {  // Wrap in IIFE to avoid global scope pollution
      // Set up dimensions
      const margin = {top: 40, right: 80, bottom: 60, left: 60}; // Increased right margin
      const width = 520 - margin.left - margin.right; // Increased overall width
      const height = 400 - margin.top - margin.bottom;

      // Create SVG
      const svg = d3.select("#diff-chart")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);
      
      // Fixed score A
      const scoreA = 50;
      
      // Calculate confidence intervals
      const calculateCI = (score, te) => {
        return [score - te * 1.96, score + te * 1.96];
      };
      
      // Calculate difference confidence interval
      const calculateDifferenceCI = (changeScore, te) => {
        const diffTE = te * Math.sqrt(2);
        return [changeScore - diffTE * 1.96, changeScore + diffTE * 1.96];
      };
      
      // Calculate MDC (Minimal Detectable Change)
      const calculateMDC = (te) => {
        return te * Math.sqrt(2) * 1.96;
      };
      
      // Calculate the smallest worthwhile change range
      const calculateSWC = (sd, multiplier) => {
        const swc = sd * multiplier;
        return [-swc, swc];
      };
      
      // Function to update interpretation text
      function updateInterpretation(changeScore, mdc, mcid) {
        let interpretationText = "";
        
        if (Math.abs(changeScore) < mdc) {
          interpretationText = "Unclear - within measurement error";
        } else if (changeScore >= mcid) {
          interpretationText = "Effect of training intervention is positive and clinically significant";
        } else if (changeScore >= mdc) {
          interpretationText = "Effect of training intervention is considered positive";
        } else if (changeScore <= -mcid) {
          interpretationText = "Effect of training intervention is negative and clinically significant";
        } else if (changeScore <= -mdc) {
          interpretationText = "Effect of training intervention is considered negative";
        } else {
          interpretationText = "Trivial change";
        }
        
        // Update the interpretation box with colored values
        d3.select("#diff-interpretation").html(`
          <strong>Interpretation:</strong> ${interpretationText}<br>
          <span style="font-size: 0.9em;">
            <span style="color: #dc3545; font-weight: bold;">MDC: ${mdc.toFixed(1)}</span> | 
            <span style="color: #007bff; font-weight: bold;">MCID: ${mcid.toFixed(1)}</span>
          </span>
        `);
      }
      
      function updateVisualization() {
        // Get current values from sliders
        const changeScore = +d3.select("#diff-change-score-slider").property("value");
        const typicalError = +d3.select("#diff-typical-error-slider").property("value");
        const betweenSubjectSD = +d3.select("#diff-between-subject-sd-slider").property("value");
        const sdMultiplier = +d3.select("#diff-sd-multiplier-slider").property("value");
        const showCI = d3.select("#diff-show-ci-toggle").property("checked");
        const showSWC = d3.select("#diff-show-swc-toggle").property("checked");
        const showMDC = d3.select("#diff-show-mdc-toggle").property("checked");
        const showMCID = d3.select("#diff-show-mcid-toggle").property("checked");
        
        // Calculate score B from change score
        const scoreB = scoreA + changeScore;
        
        // Calculate CIs
        const ciA = calculateCI(scoreA, typicalError);
        const ciB = calculateCI(scoreB, typicalError);
        const ciDiff = calculateDifferenceCI(changeScore, typicalError);
        
        // Calculate MDC and MCID
        const mdc = calculateMDC(typicalError);
        const swc = calculateSWC(betweenSubjectSD, sdMultiplier);
        const swcPositive = Math.abs(swc[1]);
        const mcid = mdc + swcPositive;
        
        // Clear previous elements
        svg.selectAll("*").remove();
        
        // Fixed ranges with equivalent unit scaling
        const leftAxisMin = 0;
        const leftAxisMax = 100;
        
        // Make difference axis use the same unit scale, but centered at 0 = scoreA (50)
        const rightAxisMin = -50;  // This will be scoreA - 50
        const rightAxisMax = 50;   // This will be scoreA + 50
        
        // Set up scales
        const xScale = d3.scaleBand()
          .domain(['A', 'B', 'Difference'])
          .range([0, width])
          .padding(0.4);
        
        const yScaleLeft = d3.scaleLinear()
          .domain([leftAxisMin, leftAxisMax])
          .range([height, 0]);
        
        const yScaleRight = d3.scaleLinear()
          .domain([rightAxisMin, rightAxisMax])
          .range([height, 0]);
        
        // Add axes
        const xAxis = d3.axisBottom(xScale);
        svg.append("g")
          .attr("transform", `translate(0,${height})`)
          .call(xAxis)
          .style("font-size", "14px");
        
        const yAxisLeft = d3.axisLeft(yScaleLeft);
        svg.append("g")
          .call(yAxisLeft)
          .style("font-size", "12px");
        
        const yAxisRight = d3.axisRight(yScaleRight);
        svg.append("g")
          .attr("transform", `translate(${width},0)`)
          .call(yAxisRight)
          .style("font-size", "12px");
        
        // Add axis labels
        svg.append("text")
          .attr("x", -margin.left + 20)
          .attr("y", height / 2)
          .attr("transform", `rotate(-90, ${-margin.left + 20}, ${height / 2})`)
          .style("text-anchor", "middle")
          .text("Dependent variable");
        
        svg.append("text")
          .attr("x", width + margin.right - 30)
          .attr("y", height / 2)
          .attr("transform", `rotate(-90, ${width + margin.right - 30}, ${height / 2})`)
          .style("text-anchor", "middle")
          .text("Difference");
        
        // Add SWC gray box before other elements so it appears in the background
        if (showSWC) {
          const swcRange = calculateSWC(betweenSubjectSD, sdMultiplier);
          const xDiff = xScale('Difference') + xScale.bandwidth() / 2;
          
          // Add SWC gray box - extending all the way to the right edge
          svg.append("rect")
            .attr("x", xDiff - 10)
            .attr("y", yScaleRight(swcRange[1]))
            .attr("width", width - (xDiff - 10))
            .attr("height", yScaleRight(swcRange[0]) - yScaleRight(swcRange[1]))
            .attr("fill", "gray")
            .attr("opacity", 0.3);
            
          // SWC labels - positioning directly at the SWC values on the secondary y-axis
          svg.append("text")
            .attr("x", width - 5)
            .attr("y", yScaleRight(swcRange[1]))
            .attr("text-anchor", "end")
            .attr("dominant-baseline", "middle")
            .style("font-size", "10px")
            .text(`${swcRange[1].toFixed(1)}`);
            
          svg.append("text")
            .attr("x", width - 5)
            .attr("y", yScaleRight(swcRange[0]))
            .attr("text-anchor", "end")
            .attr("dominant-baseline", "middle")
            .style("font-size", "10px")
            .text(`${swcRange[0].toFixed(1)}`);
        }
        
        // Add MDC lines if toggled on
        if (showMDC) {
          const xDiff = xScale('Difference') + xScale.bandwidth() / 2;
          
          // Positive MDC line
          svg.append("line")
            .attr("x1", xDiff - 10)
            .attr("x2", width)
            .attr("y1", yScaleRight(mdc))
            .attr("y2", yScaleRight(mdc))
            .attr("stroke", "#dc3545")
            .attr("stroke-width", 1.5)
            .attr("stroke-dasharray", "4");
          
          // Negative MDC line
          svg.append("line")
            .attr("x1", xDiff - 10)
            .attr("x2", width)
            .attr("y1", yScaleRight(-mdc))
            .attr("y2", yScaleRight(-mdc))
            .attr("stroke", "#dc3545")
            .attr("stroke-width", 1.5)
            .attr("stroke-dasharray", "4");
          
          // Removing the MDC labels on the lines as requested
        }
        
        // Add MCID lines if toggled on
        if (showMCID) {
          const xDiff = xScale('Difference') + xScale.bandwidth() / 2;
          
          // Positive MCID line
          svg.append("line")
            .attr("x1", xDiff - 10)
            .attr("x2", width)
            .attr("y1", yScaleRight(mcid))
            .attr("y2", yScaleRight(mcid))
            .attr("stroke", "#007bff")
            .attr("stroke-width", 1.5)
            .attr("stroke-dasharray", "4");
          
          // Negative MCID line
          svg.append("line")
            .attr("x1", xDiff - 10)
            .attr("x2", width)
            .attr("y1", yScaleRight(-mcid))
            .attr("y2", yScaleRight(-mcid))
            .attr("stroke", "#007bff")
            .attr("stroke-width", 1.5)
            .attr("stroke-dasharray", "4");
          
          // Removing the MCID labels on the lines as requested
        }
        
        // Add data points and error bars for A & B
        const pointGroups = ['A', 'B'];
        pointGroups.forEach(group => {
          const x = xScale(group) + xScale.bandwidth() / 2;
          const score = group === 'A' ? scoreA : scoreB;
          const ci = group === 'A' ? ciA : ciB;
          
          if (showCI) {
            // Error bar
            svg.append("line")
              .attr("x1", x)
              .attr("x2", x)
              .attr("y1", yScaleLeft(ci[0]))
              .attr("y2", yScaleLeft(ci[1]))
              .attr("stroke", "black")
              .attr("stroke-width", 1.5);
              
            // Top cap
            svg.append("line")
              .attr("x1", x - 5)
              .attr("x2", x + 5)
              .attr("y1", yScaleLeft(ci[1]))
              .attr("y2", yScaleLeft(ci[1]))
              .attr("stroke", "black")
              .attr("stroke-width", 1.5);
              
            // Bottom cap
            svg.append("line")
              .attr("x1", x - 5)
              .attr("x2", x + 5)
              .attr("y1", yScaleLeft(ci[0]))
              .attr("y2", yScaleLeft(ci[0]))
              .attr("stroke", "black")
              .attr("stroke-width", 1.5);
          }
          
          // Data point
          svg.append("circle")
            .attr("cx", x)
            .attr("cy", yScaleLeft(score))
            .attr("r", 5)
            .attr("fill", "black");
          
          // Mean value - moved to the left side
          svg.append("text")
            .attr("x", x - 10)
            .attr("y", yScaleLeft(score))
            .attr("text-anchor", "end")
            .attr("dominant-baseline", "middle")
            .style("font-size", "12px")
            .text(`${score.toFixed(1)}`);
          
          if (showCI) {
            // Upper CI - keep on right side
            svg.append("text")
              .attr("x", x + 10)
              .attr("y", yScaleLeft(ci[1]))
              .attr("text-anchor", "start")
              .attr("dominant-baseline", "middle")
              .style("font-size", "10px")
              .text(`${ci[1].toFixed(1)}`);
              
            // Lower CI - keep on right side
            svg.append("text")
              .attr("x", x + 10)
              .attr("y", yScaleLeft(ci[0]))
              .attr("text-anchor", "start")
              .attr("dominant-baseline", "middle")
              .style("font-size", "10px")
              .text(`${ci[0].toFixed(1)}`);
          }
        });
        
        // Add the difference point and error bar
        const xDiff = xScale('Difference') + xScale.bandwidth() / 2;
        
        if (showCI) {
          // Error bar for difference
          svg.append("line")
            .attr("x1", xDiff)
            .attr("x2", xDiff)
            .attr("y1", yScaleRight(ciDiff[0]))
            .attr("y2", yScaleRight(ciDiff[1]))
            .attr("stroke", "black")
            .attr("stroke-width", 1.5);
            
          // Top cap
          svg.append("line")
            .attr("x1", xDiff - 5)
            .attr("x2", xDiff + 5)
            .attr("y1", yScaleRight(ciDiff[1]))
            .attr("y2", yScaleRight(ciDiff[1]))
            .attr("stroke", "black")
            .attr("stroke-width", 1.5);
            
          // Bottom cap
          svg.append("line")
            .attr("x1", xDiff - 5)
            .attr("x2", xDiff + 5)
            .attr("y1", yScaleRight(ciDiff[0]))
            .attr("y2", yScaleRight(ciDiff[0]))
            .attr("stroke", "black")
            .attr("stroke-width", 1.5);
        }
        
        // Calculate reference lines to properly align with the right axis
        const scoreARef = ((scoreA - leftAxisMin) / (leftAxisMax - leftAxisMin)) * (rightAxisMax - rightAxisMin) + rightAxisMin;
        const scoreBRef = ((scoreB - leftAxisMin) / (leftAxisMax - leftAxisMin)) * (rightAxisMax - rightAxisMin) + rightAxisMin;
        
        // Difference point (triangle) - aligned with change value
        svg.append("path")
          .attr("d", d3.symbol().type(d3.symbolTriangle).size(100))
          .attr("transform", `translate(${xDiff}, ${yScaleRight(changeScore)})`)
          .attr("fill", "black");
        
        // Change value - keep on right side
        svg.append("text")
          .attr("x", xDiff + 10)
          .attr("y", yScaleRight(changeScore))
          .attr("text-anchor", "start")
          .attr("dominant-baseline", "middle")
          .style("font-size", "12px")
          .text(`${changeScore.toFixed(1)}`);
        
        if (showCI) {
          // Upper CI for difference - keep on right side
          svg.append("text")
            .attr("x", xDiff + 10)
            .attr("y", yScaleRight(ciDiff[1]))
            .attr("text-anchor", "start")
            .attr("dominant-baseline", "middle")
            .style("font-size", "10px")
            .text(`${ciDiff[1].toFixed(1)}`);
            
          // Lower CI for difference - keep on right side
          svg.append("text")
            .attr("x", xDiff + 10)
            .attr("y", yScaleRight(ciDiff[0]))
            .attr("text-anchor", "start")
            .attr("dominant-baseline", "middle")
            .style("font-size", "10px")
            .text(`${ciDiff[0].toFixed(1)}`);
        }
        
        // Add horizontal reference line from A to Difference - aligned with points
        svg.append("line")
          .attr("x1", xScale('A') + xScale.bandwidth() / 2)
          .attr("x2", xDiff)
          .attr("y1", yScaleLeft(scoreA))
          .attr("y2", yScaleRight(scoreARef))
          .attr("stroke", "black")
          .attr("stroke-width", 1)
          .attr("stroke-dasharray", "3,3");
        
        // Add horizontal reference line from B to Difference - aligned with points
        svg.append("line")
          .attr("x1", xScale('B') + xScale.bandwidth() / 2)
          .attr("x2", xDiff)
          .attr("y1", yScaleLeft(scoreB))
          .attr("y2", yScaleRight(scoreBRef))
          .attr("stroke", "black")
          .attr("stroke-width", 1)
          .attr("stroke-dasharray", "3,3");
          
        if (showCI) {
          // Add MDC value text with matching color
          svg.append("text")
            .attr("x", width - 10)
            .attr("y", 20)
            .attr("text-anchor", "end")
            .style("font-size", "12px")
            .style("fill", "#dc3545")  // Red to match MDC lines
            .text(`MDC95: ${mdc.toFixed(1)}`);
          
          const swcPositive = Math.abs(swc[1]); 
          svg.append("text")
            .attr("x", width - 10)
            .attr("y", 40)
            .attr("text-anchor", "end")
            .style("font-size", "12px")
            .style("fill", "#007bff")  // Blue to match MCID lines
            .text(`MCID95: ${mcid.toFixed(1)}`);
        }
        
        // Update interpretation text
        updateInterpretation(changeScore, mdc, mcid);
          
        // Update slider value displays
        d3.select("#diff-change-score-value").text(changeScore);
        d3.select("#diff-typical-error-value").text(typicalError);
        d3.select("#diff-between-subject-sd-value").text(betweenSubjectSD);
        d3.select("#diff-sd-multiplier-value").text(sdMultiplier.toFixed(2));
      }
      
      // Initialize the visualization
      updateVisualization();
      
      // Set up event listeners for sliders and toggle
      d3.selectAll(".diff-container input").on("input change", updateVisualization);
      
      // Initialize slider value displays
      d3.selectAll(".diff-container input[type='range']").each(function() {
        const id = this.id;
        const value = this.value;
        const valueId = `#${id.replace("slider", "value")}`;
        
        if (id.includes("sd-multiplier")) {
          d3.select(valueId).text(parseFloat(value).toFixed(2));
        } else {
          d3.select(valueId).text(value);
        }
      });
    })();
  </script>
</div>
<p>Two more measures we discussed in the lecture that can also be calculated from an understanding of TE are the minimal detectable change <strong>MDC</strong> and minimal clinically import difference <strong>MCID</strong>. Both of these are commonly reported to a 95% confidence level so will be multiplied by 1.96 respectively. The key take away is that the <strong>MDC</strong> is looking to tell you how the large the change would need to be for you to be confident at the 95% level that the observed change wasn’t due to measurement noise. However the <strong>MDC</strong> only tells you whether a change is statistically different from zero which may not indicate that the change is meaningful in a practical sense. The <strong>MCID</strong> however, aims to let you know whether the change observed is greater than some magnitude of importance often termed the <strong>smallest worthwhile change (SWC)</strong>.</p>
<p><strong>MDC_95</strong> = TE <span class="math inline">\(\times\)</span> <span class="math inline">\(\sqrt{2}\)</span> <span class="math inline">\(\times\)</span> 1.96<br>
<strong>MCID_95</strong> = MDC_95 + <strong>SWC</strong></p>
<p>Whilst there are may ways we can identify a value considered the <strong>SWC</strong>, a commonly used method is to multiply the between subject SD by some factor. In exercise and sport science a commonly used factor is 0.2 therefore;</p>
<p><strong>SWC<sub>sml</sub></strong> = SD <span class="math inline">\(\times\)</span> 0.2 (Small)<br>
<strong>SWC<sub>mdr</sub></strong> = SD <span class="math inline">\(\times\)</span> 0.6 (Moderate)<br>
<strong>SWC<sub>lrg</sub></strong> = SD <span class="math inline">\(\times\)</span> 1.2 (Large)<br>
</p>
</section>
</section>
<section id="test-your-learning" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="test-your-learning"><span class="header-section-number">2.6</span> Test your learning</h2>
<p><br></p>
What does a Bland-Altman plot show?
<div id="radio_CDMXFPBYBQ" class="webex-radiogroup">
<label><input type="radio" autocomplete="off" name="radio_CDMXFPBYBQ" value=""> <span>The difference between measurements plotted against time</span></label><label><input type="radio" autocomplete="off" name="radio_CDMXFPBYBQ" value="answer"> <span>The difference between measurements plotted against the mean of both measurements</span></label><label><input type="radio" autocomplete="off" name="radio_CDMXFPBYBQ" value=""> <span>The correlation between two measurements</span></label><label><input type="radio" autocomplete="off" name="radio_CDMXFPBYBQ" value=""> <span>The mean of both measurements plotted against time</span></label>
</div>
What does the mean difference line (bias) in a Bland-Altman plot represent?
<div id="radio_SPIWDFFRYH" class="webex-radiogroup">
<label><input type="radio" autocomplete="off" name="radio_SPIWDFFRYH" value=""> <span>Random error in the measurements</span></label><label><input type="radio" autocomplete="off" name="radio_SPIWDFFRYH" value=""> <span>The standard deviation of the differences</span></label><label><input type="radio" autocomplete="off" name="radio_SPIWDFFRYH" value="answer"> <span>Systematic differences between measurements</span></label><label><input type="radio" autocomplete="off" name="radio_SPIWDFFRYH" value=""> <span>The reliability of the measurement</span></label>
</div>
What does the Typical Error (TE) represent?
<div id="radio_VDFMXIDUNM" class="webex-radiogroup">
<label><input type="radio" autocomplete="off" name="radio_VDFMXIDUNM" value=""> <span>The average difference between measurements</span></label><label><input type="radio" autocomplete="off" name="radio_VDFMXIDUNM" value="answer"> <span>The typical variation in repeated measurements for an individual</span></label><label><input type="radio" autocomplete="off" name="radio_VDFMXIDUNM" value=""> <span>The minimum detectable change</span></label><label><input type="radio" autocomplete="off" name="radio_VDFMXIDUNM" value=""> <span>The correlation between measurements</span></label>
</div>
If you have a single measurement (e.g., 45 kg) and know the Typical Error (TE) is 2 kg, how would you construct a 95% confidence interval around this measurement?
<div id="radio_MHBCXIPCQN" class="webex-radiogroup">
<label><input type="radio" autocomplete="off" name="radio_MHBCXIPCQN" value=""> <span>Add and subtract 1×TE from the measurement</span></label><label><input type="radio" autocomplete="off" name="radio_MHBCXIPCQN" value="answer"> <span>Add and subtract 1.96×TE from the measurement</span></label><label><input type="radio" autocomplete="off" name="radio_MHBCXIPCQN" value=""> <span>Add and subtract 2×TE from the measurement</span></label><label><input type="radio" autocomplete="off" name="radio_MHBCXIPCQN" value=""> <span>Add and subtract the MDC95 from the measurement</span></label>
</div>
If you measure an athlete’s max strength as 80 kg with a TE of 3 kg and calculate a 95% confidence interval of 74.1-85.9 kg, what does this interval represent?
<div id="radio_TNCZOMDAYM" class="webex-radiogroup">
<label><input type="radio" autocomplete="off" name="radio_TNCZOMDAYM" value=""> <span>The athlete will score between 74.1-85.9 kg on 95% of future tests</span></label><label><input type="radio" autocomplete="off" name="radio_TNCZOMDAYM" value=""> <span>95% of athletes with similar measured strength have a true strength in this range</span></label><label><input type="radio" autocomplete="off" name="radio_TNCZOMDAYM" value="answer"> <span>If we could measure this athlete's strength at this exact moment repeatedly without fatigue, 95% of the confidence intervals calculated using the above procedure would contain their true strength</span></label><label><input type="radio" autocomplete="off" name="radio_TNCZOMDAYM" value=""> <span>The athlete's strength will improve by up to 5.9 kg or decrease by up to 5.9 kg with 95% probability</span></label>
</div>
What does the Minimum Detectable Change (MDC95) represent?
<div id="radio_PVCMJKLDAL" class="webex-radiogroup">
<label><input type="radio" autocomplete="off" name="radio_PVCMJKLDAL" value=""> <span>The smallest change that could occur by chance</span></label><label><input type="radio" autocomplete="off" name="radio_PVCMJKLDAL" value=""> <span>The average change between measurements</span></label><label><input type="radio" autocomplete="off" name="radio_PVCMJKLDAL" value="answer"> <span>The minimum change needed to be confident a real change has occurred at the 95% confidence level</span></label><label><input type="radio" autocomplete="off" name="radio_PVCMJKLDAL" value=""> <span>The typical error multiplied by 0.68</span></label>
</div>
When monitoring an individual’s changes over time, which criterion should you use to determine if a real change has occurred?
<div id="radio_URKXGYTEBM" class="webex-radiogroup">
<label><input type="radio" autocomplete="off" name="radio_URKXGYTEBM" value=""> <span>The change is significant if it exceeds the TE</span></label><label><input type="radio" autocomplete="off" name="radio_URKXGYTEBM" value="answer"> <span>The change is significant if it exceeds the MDC95</span></label><label><input type="radio" autocomplete="off" name="radio_URKXGYTEBM" value=""> <span>The change is significant if it exceeds the mean bias</span></label><label><input type="radio" autocomplete="off" name="radio_URKXGYTEBM" value=""> <span>The change is significant if it exceeds the CV</span></label>
</div>
Why is the Coefficient of Variation (CVTE%) useful?
<div id="radio_MLOCDDFZMR" class="webex-radiogroup">
<label><input type="radio" autocomplete="off" name="radio_MLOCDDFZMR" value=""> <span>It allows comparison of reliability between different units</span></label><label><input type="radio" autocomplete="off" name="radio_MLOCDDFZMR" value=""> <span>It expresses error relative to the mean</span></label><label><input type="radio" autocomplete="off" name="radio_MLOCDDFZMR" value=""> <span>It's useful when error increases with larger values</span></label><label><input type="radio" autocomplete="off" name="radio_MLOCDDFZMR" value="answer"> <span>All of the above</span></label>
</div>
If you want to construct a 95% confidence interval around an individual’s measurement, you should use:
<div id="radio_BCCKAXPSVX" class="webex-radiogroup">
<label><input type="radio" autocomplete="off" name="radio_BCCKAXPSVX" value=""> <span>±1 × TE from the measured value</span></label><label><input type="radio" autocomplete="off" name="radio_BCCKAXPSVX" value="answer"> <span>±1.96 × TE from the measured value</span></label><label><input type="radio" autocomplete="off" name="radio_BCCKAXPSVX" value=""> <span>±1 × MDC from the measured value</span></label><label><input type="radio" autocomplete="off" name="radio_BCCKAXPSVX" value=""> <span>±2 × CV from the measured value</span></label>
</div>


</section>

</main> <!-- /main -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>

<script>

/* update total correct if #webex-total_correct exists */
update_total_correct = function() {
  console.log("webex: update total_correct");

  var t = document.getElementsByClassName("webex-total_correct");
  for (var i = 0; i < t.length; i++) {
    p = t[i].parentElement;
    var correct = p.getElementsByClassName("webex-correct").length;
    var solvemes = p.getElementsByClassName("webex-solveme").length;
    var radiogroups = p.getElementsByClassName("webex-radiogroup").length;
    var selects = p.getElementsByClassName("webex-select").length;

    t[i].innerHTML = correct + " of " + (solvemes + radiogroups + selects) + " correct";
  }
}

/* webex-solution button toggling function */
b_func = function() {
  console.log("webex: toggle hide");

  var cl = this.parentElement.classList;
  if (cl.contains('open')) {
    cl.remove("open");
  } else {
    cl.add("open");
  }
}

/* check answers */
check_func = function() {
  console.log("webex: check answers");

  var cl = this.parentElement.classList;
  if (cl.contains('unchecked')) {
    cl.remove("unchecked");
    this.innerHTML = "Hide Answers";
  } else {
    cl.add("unchecked");
    this.innerHTML = "Show Answers";
  }
}

/* function for checking solveme answers */
solveme_func = function(e) {
  console.log("webex: check solveme");

  var real_answers = JSON.parse(this.dataset.answer);
  var my_answer = this.value;
  var cl = this.classList;
  if (cl.contains("ignorecase")) {
    my_answer = my_answer.toLowerCase();
  }
  if (cl.contains("nospaces")) {
    my_answer = my_answer.replace(/ /g, "")
  }

  if (my_answer == "") {
    cl.remove("webex-correct");
    cl.remove("webex-incorrect");
  } else if (real_answers.includes(my_answer)) {
    cl.add("webex-correct");
    cl.remove("webex-incorrect");
  } else {
    cl.add("webex-incorrect");
    cl.remove("webex-correct");
  }

  // match numeric answers within a specified tolerance
  if(this.dataset.tol > 0){
    var tol = JSON.parse(this.dataset.tol);
    var matches = real_answers.map(x => Math.abs(x - my_answer) < tol)
    if (matches.reduce((a, b) => a + b, 0) > 0) {
      cl.add("webex-correct");
    } else {
      cl.remove("webex-correct");
    }
  }

  // added regex bit
  if (cl.contains("regex")){
    answer_regex = RegExp(real_answers.join("|"))
    if (answer_regex.test(my_answer)) {
      cl.add("webex-correct");
    }
  }

  update_total_correct();
}

/* function for checking select answers */
select_func = function(e) {
  console.log("webex: check select");

  var cl = this.classList

  /* add style */
  cl.remove("webex-incorrect");
  cl.remove("webex-correct");
  if (this.value == "answer") {
    cl.add("webex-correct");
  } else if (this.value != "blank") {
    cl.add("webex-incorrect");
  }

  update_total_correct();
}

/* function for checking radiogroups answers */
radiogroups_func = function(e) {
  console.log("webex: check radiogroups");

  var checked_button = document.querySelector('input[name=' + this.id + ']:checked');
  var cl = checked_button.parentElement.classList;
  var labels = checked_button.parentElement.parentElement.children;

  /* get rid of styles */
  for (i = 0; i < labels.length; i++) {
    labels[i].classList.remove("webex-incorrect");
    labels[i].classList.remove("webex-correct");
  }

  /* add style */
  if (checked_button.value == "answer") {
    cl.add("webex-correct");
  } else {
    cl.add("webex-incorrect");
  }

  update_total_correct();
}

window.onload = function() {
  console.log("webex onload");
  /* set up solution buttons */
  var buttons = document.getElementsByTagName("button");

  for (var i = 0; i < buttons.length; i++) {
    if (buttons[i].parentElement.classList.contains('webex-solution')) {
      buttons[i].onclick = b_func;
    }
  }

  var check_sections = document.getElementsByClassName("webex-check");
  console.log("check:", check_sections.length);
  for (var i = 0; i < check_sections.length; i++) {
    check_sections[i].classList.add("unchecked");

    let btn = document.createElement("button");
    btn.innerHTML = "Show Answers";
    btn.classList.add("webex-check-button");
    btn.onclick = check_func;
    check_sections[i].appendChild(btn);

    let spn = document.createElement("span");
    spn.classList.add("webex-total_correct");
    check_sections[i].appendChild(spn);
  }

  /* set up webex-solveme inputs */
  var solveme = document.getElementsByClassName("webex-solveme");

  for (var i = 0; i < solveme.length; i++) {
    /* make sure input boxes don't auto-anything */
    solveme[i].setAttribute("autocomplete","off");
    solveme[i].setAttribute("autocorrect", "off");
    solveme[i].setAttribute("autocapitalize", "off");
    solveme[i].setAttribute("spellcheck", "false");
    solveme[i].value = "";

    /* adjust answer for ignorecase or nospaces */
    var cl = solveme[i].classList;
    var real_answer = solveme[i].dataset.answer;
    if (cl.contains("ignorecase")) {
      real_answer = real_answer.toLowerCase();
    }
    if (cl.contains("nospaces")) {
      real_answer = real_answer.replace(/ /g, "");
    }
    solveme[i].dataset.answer = real_answer;

    /* attach checking function */
    solveme[i].onkeyup = solveme_func;
    solveme[i].onchange = solveme_func;

    $(solveme[i]).after(" <span class='webex-icon'></span>");
  }

  /* set up radiogroups */
  var radiogroups = document.getElementsByClassName("webex-radiogroup");
  for (var i = 0; i < radiogroups.length; i++) {
    radiogroups[i].onchange = radiogroups_func;
  }

  /* set up selects */
  var selects = document.getElementsByClassName("webex-select");
  for (var i = 0; i < selects.length; i++) {
    selects[i].onchange = select_func;
    $(selects[i]).after(" <span class='webex-icon'></span>");
  }

  update_total_correct();
}

</script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Practical1.html" class="pagination-link" aria-label="Week 2 - Practical">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Week 2 - Practical</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Practical3.html" class="pagination-link" aria-label="Week 4 - Practical">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Week 4 - Practical</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>